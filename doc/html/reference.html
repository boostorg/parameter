<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator"
content="Docutils 0.7: http://docutils.sourceforge.net/" />
<title>The Boost Parameter Library Reference Documentation</title>
<meta name="authors" content="David Abrahams  Daniel Wallin" />
<meta name="organization" content="BoostPro Computing" />
<meta name="date" content="2005-07-17" />
<meta name="copyright" content=
"Copyright David Abrahams, Daniel Wallin 2005-2009.  Distributed under the
Boost Software License, Version 1.0.  (See accompanying file LICENSE_1_0.txt
or copy at http://www.boost.org/LICENSE_1_0.txt)"
/>
<link rel="stylesheet" href="rst.css" type="text/css" />
</head>
<body>
<div class="document"
id="the-boost-parameter-library-reference-documentation">
<h1 class="title">The Boost Parameter Library Reference Documentation</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr>
<th class="docinfo-name">Authors:</th>
<td>David Abrahams<br />Daniel Wallin</td>
</tr>
<tr>
<th class="docinfo-name">Contact:</th>
<td><a class="first reference external"
href="mailto:dave&#64;boost-consulting.com">dave&#64;boost-consulting.com</a>,
<a class="last reference external" href="mailto:daniel&#64;boostpro.com"
>daniel&#64;boostpro.com</a></td>
</tr>
<tr><th class="docinfo-name">Organization:</th>
<td><a class="first last reference external"
href="http://www.boostpro.com">BoostPro Computing</a></td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2005-07-17</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>Copyright David Abrahams, Daniel Wallin 2005-2009.  Distributed under the
Boost Software License, Version 1.0.  (See accompanying file LICENSE_1_0.txt
or copy at <a class="reference external"
href="http://www.boost.org/LICENSE_1_0.txt"
>http://www.boost.org/LICENSE_1_0.txt</a>)</td></tr>
</tbody>
</table>
<p><a class="reference external" href="../../../../index.htm"><img alt="Boost"
src="../../../../boost.png" /></a></p>
<hr class="docutils" />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#preliminaries" id="id30"
>1&nbsp;&nbsp;&nbsp;Preliminaries</a>
<ul class="auto-toc">
<li><a class="reference internal" href="#namespaces" id="id31"
>1.1&nbsp;&nbsp;&nbsp;Namespaces</a></li>
<li><a class="reference internal" href="#exceptions" id="id32"
>1.2&nbsp;&nbsp;&nbsp;Exceptions</a></li>
<li><a class="reference internal" href="#thread-safety" id="id33"
>1.3&nbsp;&nbsp;&nbsp;Thread Safety</a></li>
<li><a class="reference internal" href="#typography" id="id34"
>1.4&nbsp;&nbsp;&nbsp;Typography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#terminology" id="id35"
>2&nbsp;&nbsp;&nbsp;Terminology</a></li>
<li><a class="reference internal" href="#concepts" id="id36"
>3&nbsp;&nbsp;&nbsp;Concepts</a>
<ul class="auto-toc">
<li><a class="reference internal" href="#argumentpack" id="id37"
>3.1&nbsp;&nbsp;&nbsp;<span class="concept">ArgumentPack</span></a></li>
<li><a class="reference internal" href="#id5" id="id38"
>3.2&nbsp;&nbsp;&nbsp;<span class="concept">ParameterSpec</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-templates" id="id39"
>4&nbsp;&nbsp;&nbsp;Class Templates</a><ul class="auto-toc">
<li><a class="reference internal" href="#id7" id="id40"
>4.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal">keyword</tt></a></li>
<li><a class="reference internal" href="#template-keyword" id="id41"
>4.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>template_keyword</tt></a></li>
<li><a class="reference internal" href="#parameters" id="id42"
>4.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal">parameters</tt></a></li>
<li><a class="reference internal" href="#optional-required" id="id43"
>4.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal">optional</tt>,
<tt class="docutils literal">required</tt></a></li>
<li><a class="reference internal" href="#deduced" id="id44"
>4.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal">deduced</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#metafunctions" id="id45"
>5&nbsp;&nbsp;&nbsp;Metafunctions</a><ul class="auto-toc">
<li><a class="reference internal" href="#binding" id="id46"
>5.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal">binding</tt></a></li>
<li><a class="reference internal" href="#lazy-binding" id="id47"
>5.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal">lazy_binding</tt></a></li>
<li><a class="reference internal" href="#value-type" id="id48"
>5.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal">value_type</tt></a></li>
<li><a class="reference internal" href="#are-tagged-arguments" id="id49"
>5.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>are_tagged_arguments</tt></a></li>
<li><a class="reference internal" href="#is-argument-pack" id="id51"
>5.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>is_argument_pack</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-templates" id="id53"
>6&nbsp;&nbsp;&nbsp;Function Templates</a>
<ul class="auto-toc">
<li><a class="reference internal" href="#compose" id="id54"
>6.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal">compose</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#code-generation-macros" id="id55"
>7&nbsp;&nbsp;&nbsp;Code Generation Macros</a><ul class="auto-toc">
<li><a class="reference internal"
href="#boost-parameter-function-result-name-tag-namespace-arguments"
id="id56">7.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_FUNCTION(result, name, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-member-function-result-name-tag-namespace-arguments"
id="id57">7.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_MEMBER_FUNCTION(result, name, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-c-mem-function-result-name-tag-namespace-arguments"
id="id58">7.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_CONST_MEMBER_FUNCTION(result, name, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-function-call-op-result-tag-namespace-arguments"
id="id59">7.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_FUNCTION_CALL_OPERATOR(result, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-const-function-call-op-result-tag-namespace-arguments"
id="id60">7.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_CONST_FUNCTION_CALL_OPERATOR(result, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-constructor-cls-impl-tag-namespace-arguments"
id="id61">7.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_CONSTRUCTOR(cls, impl, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-basic-function-result-name-tag-namespace-arguments"
id="id62">7.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_BASIC_FUNCTION(result, name, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-basic-member-function-result-name-tag-ns-arguments"
id="id63">7.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_BASIC_MEMBER_FUNCTION(result, name, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-basic-c-mem-function-result-name-tag-ns-arguments"
id="id64">7.9&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_BASIC_CONST_MEMBER_FUNCTION(result, name, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-basic-function-call-op-result-tag-namespace-arguments"
id="id65">7.10&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_BASIC_FUNCTION_CALL_OPERATOR(result, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-basic-const-function-call-op-result-tag-ns-args"
id="id66">7.11&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_BASIC_CONST_FUNCTION_CALL_OPERATOR(result, tag_namespace,
arguments)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-no-spec-function-result-name"
id="id67">7.12&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_FUNCTION(result, name)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-no-spec-member-function-result-name"
id="id68">7.13&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_MEMBER_FUNCTION(result, name)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-no-spec-c-mem-function-result-name"
id="id69">7.14&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_CONST_MEMBER_FUNCTION(result, name)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-no-spec-function-call-op-result"
id="id70">7.15&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_FUNCTION_CALL_OPERATOR(result)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-no-spec-const-func-call-op-result"
id="id71">7.16&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_CONST_FUNCTION_CALL_OPERATOR(result)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-no-spec-constructor-cls-impl"
id="id72">7.17&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_CONSTRUCTOR(cls, impl)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-no-spec-no-base-ctor-cls-func"
id="id73">7.18&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_NO_BASE_CONSTRUCTOR(cls, func)</tt></a></li>
<li><a class="reference internal" href="#boost-parameter-name-name"
id="id74">7.19&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NAME(name)</tt></a></li>
<li><a class="reference internal" href="#boost-parameter-nested-keyword-t-n-a"
id="id75">7.20&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_NESTED_KEYWORD(tag_namespace, name, alias)</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-template-keyword-name"
id="id76">7.21&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_TEMPLATE_KEYWORD(name)</tt></a></li>
<li><a class="reference internal" href="#boost-parameter-fun-r-n-l-h-p"
id="id77">7.22&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_FUN(r,n,l,h,p)</tt></a></li>
<li><a class="reference internal" href="#boost-parameter-keyword-n-k"
id="id78">7.23&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_KEYWORD(n,k)</tt></a></li>
<li><a class="reference internal" href="#boost-parameter-match-p-a-x"
id="id79">7.24&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_MATCH(p,a,x)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration-macros"
id="id80">8&nbsp;&nbsp;&nbsp;Configuration Macros</a>
<ul class="auto-toc">
<li><a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"
id="id81">8.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-disable-perfect-forwarding"
id="id82">8.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_DISABLE_PERFECT_FORWARDING</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-can-use-mp11"
id="id83">8.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_CAN_USE_MP11</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-disable-mp11-usage"
id="id84">8.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_DISABLE_MP11_USAGE</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-variadic-mpl-sequence"
id="id85">8.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_VARIADIC_MPL_SEQUENCE</tt></a></li>
<li><a class="reference internal" href="#boost-parameter-max-arity"
id="id86">8.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_MAX_ARITY</tt></a></li>
<li><a class="reference internal" href="#boost-parameter-compose-max-arity"
id="id87">8.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_COMPOSE_MAX_ARITY</tt></a></li>
<li><a class="reference internal"
href="#boost-parameter-exponential-overload-threshold-arity"
id="id88">8.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"
>BOOST_PARAMETER_EXPONENTIAL_OVERLOAD_THRESHOLD_ARITY</tt></a></li>
<li><a class="reference internal" href="#outside-of-this-library"
id="id89">8.9&nbsp;&nbsp;&nbsp;...Outside Of This Library</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial"
id="id90">9&nbsp;&nbsp;&nbsp;Tutorial</a></li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="preliminaries">
<h1><a class="toc-backref"
href="#id30">1&nbsp;&nbsp;&nbsp;Preliminaries</a></h1>
<p>This section covers some basic information you'll need to know in order to
understand this reference</p>
<div class="section" id="namespaces">
<h2><a class="toc-backref"
href="#id31">1.1&nbsp;&nbsp;&nbsp;Namespaces</a></h2>
<p>In this document, all unqualified identifiers should be assumed to be
defined in namespace
<tt class="docutils literal"><span class="pre">boost::parameter</span></tt>
unless otherwise specified.</p>
</div>
<div class="section" id="exceptions">
<h2><a class="toc-backref"
href="#id32">1.2&nbsp;&nbsp;&nbsp;Exceptions</a></h2>
<p>No operation described in this document throws an exception unless
otherwise specified.</p>
</div>
<div class="section" id="thread-safety">
<h2><a class="toc-backref"
href="#id33">1.3&nbsp;&nbsp;&nbsp;Thread Safety</a></h2>
<p>All components of this library can be used safely from multiple
threads without synchronization.<a class="footnote-reference" href="#thread"
id="id2"><sup>1</sup></a></p>
</div>
<div class="section" id="typography">
<h2><a class="toc-backref"
href="#id34">1.4&nbsp;&nbsp;&nbsp;Typography</a></h2>
<p>Names written in <span class="concept">sans serif type</span> represent
<a class="reference external"
href="http://www.boost.org/more/generic_programming.html#concept"
>concepts</a>.</p>
<p>In code blocks, <em>italic type</em> represents unspecified text that
satisfies the requirements given in the detailed description that follows the
code block.</p>
<p>In a specification of the tokens generated by a macro, <strong>bold
type</strong> is used to highlight the position of the expanded macro
argument in the result.</p>
<p>The special character β represents the value of
<a class="reference internal" href="#boost-parameter-max-arity"><tt
class="docutils literal">BOOST_PARAMETER_MAX_ARITY</tt></a>.</p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="terminology">
<h1><a class="toc-backref"
href="#id35">2&nbsp;&nbsp;&nbsp;Terminology</a></h1>
<dl class="docutils" id="kw">
<dt>keyword</dt>
<dd>The name of a function parameter.</dd>
</dl>
<span class="target" id="keyword-tag-type"></span><dl class="docutils">
<dt>keyword tag type</dt>
<dd>A type used to uniquely identify a function parameter.  Typically its name
will be the same as that of the parameter.</dd>
</dl>
<span class="target" id="positional"></span><dl class="docutils">
<dt>positional argument</dt>
<dd>An argument passed with no explicit keyword.  Its parameter is determined
in the usual C++ way: by position with respect to a parameter list.</dd>
</dl>
<span class="target" id="tag-type"></span><dl class="docutils">
<dt>tag type</dt>
<dd>Shorthand for “<a class="reference internal"
href="#keyword-tag-type">keyword tag type</a>.”</dd>
</dl>
<span class="target" id="keyword-object"></span><dl class="docutils">
<dt>keyword object</dt>
<dd>An instance of <a class="reference internal" href="#keyword"><tt
class="docutils literal">keyword</tt></a>
<tt class="docutils literal">&lt;T&gt;</tt> for some
<a class="reference internal" href="#tag-type">tag type</a>
<tt class="docutils literal">T</tt>.</dd>
</dl>
<span class="target" id="tagged-reference"></span><dl class="docutils">
<dt>tagged reference</dt>
<dd><p class="first">An object whose type is associated with a
<a class="reference internal" href="#keyword-tag-type">keyword tag type</a>
(the object's <em>keyword</em>), and that holds a reference (to the object's
<em>value</em>).</p>
<p class="last">As a shorthand, a “tagged reference to
<tt class="docutils literal">x</tt>” means a tagged reference whose
<em>value</em> is <tt class="docutils literal">x</tt>.</p>
</dd>
</dl>
<span class="target" id="tagged-default"></span><dl class="docutils">
<dt>tagged default</dt>
<dd>A <a class="reference internal" href="#tagged-reference">tagged
reference</a> whose <em>value</em> represents the value of a default
argument.</dd>
</dl>
<span class="target" id="tagged-lazy-default"></span><dl class="docutils">
<dt>tagged lazy default</dt>
<dd>A <a class="reference internal" href="#tagged-reference">tagged
reference</a> whose <em>value</em>, when invoked with no arguments, computes
a default argument value.</dd>
</dl>
<span class="target" id="intended-argument-type"></span><dl class="docutils">
<dt>intended argument type</dt>
<dd>The <em>intended argument type</em> of a single-element
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a> is the type of its element's <em>value</em>.  The
intended argument type of any other type <tt class="docutils literal">X</tt>
is <tt class="docutils literal">X</tt> itself.</dd>
</dl>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">In this reference, we will use concept names (and other names)
to describe both types and objects, depending on context.  So for example, “an
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a>” can refer to a type that models
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a> <em>or</em> an object of such a type.</p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="concepts">
<h1><a class="toc-backref" href="#id36">3&nbsp;&nbsp;&nbsp;Concepts</a></h1>
<p>This section describes the generic type concepts used by the Parameter
library.</p>
<div class="section" id="argumentpack">
<h2><a class="toc-backref" href="#id37">3.1&nbsp;&nbsp;&nbsp;<span
class="concept">ArgumentPack</span></a></h2>
<p>An <span class="concept">ArgumentPack</span> is a collection of
<a class="reference internal" href="#tagged-reference">tagged reference</a>s
to the actual arguments passed to a function.  Every <span class="concept"
>ArgumentPack</span> is also a valid <a class="reference external"
href="../../../mpl/doc/refmanual/forward-sequence.html"><span class="concept"
>MPL Forward Sequence</span></a> and <a class="reference external"
href="../../../mpl/doc/refmanual/associative-sequence.html"><span
class="concept">MPL Associative Sequence</span></a> consisting of the <a
class="reference internal" href="#keyword-tag-type">keyword tag type</a>s in
its <a class="reference internal" href="#tagged-reference">tagged
reference</a>s.  The <a class="reference external"
href="../../test/singular.cpp">test/singular.cpp</a>, <a
class="reference external" href="../../test/compose.cpp"
>test/compose.cpp</a>, and <a class="reference external"
href="../../test/mpl.cpp">test/mpl.cpp</a> test programs demonstrate this
functionality.</p>
<div class="section" id="requirements">
<h3>Requirements</h3>
<p>In the table below,</p>
<ul class="simple">
<li><tt class="docutils literal">A</tt> is a model of
<span class="concept">ArgumentPack</span></li>
<li><tt class="docutils literal">x</tt> is an instance of
<tt class="docutils literal">A</tt></li>
<li><tt class="docutils literal">u</tt> is a
<a class="reference internal" href="#keyword-object">keyword object</a> of
type <tt class="docutils literal">K</tt></li>
<li><tt class="docutils literal">v</tt> is a
<a class="reference internal" href="#tagged-default">tagged default</a> with
<a class="reference internal" href="#tag-type">tag type</a>
<tt class="docutils literal">L</tt> and <em>value</em> of type
<tt class="docutils literal">D</tt></li>
<li><tt class="docutils literal">w</tt> is a
<a class="reference internal" href="#tagged-lazy-default">tagged lazy
default</a> with <a class="reference internal" href="#tag-type">tag type</a>
<tt class="docutils literal">M</tt> and <em>value</em> of type
<tt class="docutils literal">E const</tt></li>
<li><tt class="docutils literal">z</tt> is an <span class="concept"
>ArgumentPack</span> containing a single element (as created by <a
class="reference internal" href="#keyword"><tt class="docutils literal"
>keyword</tt></a><tt class="docutils literal">&lt;…&gt;::operator=</tt>)</li>
</ul>
<p>Any exceptions are thrown from the invocation of
<tt class="docutils literal">w</tt>'s <em>value</em>
will be propagated to the caller.</p>
<table border="1" class="docutils">
<caption><span class="concept">ArgumentPack</span> requirements</caption>
<colgroup>
<col width="11%" />
<col width="31%" />
<col width="19%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr>
<th class="head">Expression</th>
<th class="head">Type</th>
<th class="head">Requirements</th>
<th class="head">Semantics/Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td><tt class="docutils literal">x[u]</tt></td>
<td><tt class="docutils literal">binding&lt;A,K&gt;::type</tt></td>
<td><tt class="docutils literal">x</tt> contains an element <em>b</em> whose
<a class="reference internal" href="#kw">keyword</a> is
<tt class="docutils literal">K</tt></td>
<td>Returns <em>b</em>'s <em>value</em> (by reference).</td>
</tr>
<tr>
<td><tt class="docutils literal">x[u]</tt></td>
<td><tt class="docutils literal">binding&lt;A,L,D&gt;::type</tt></td>
<td><em>none</em></td>
<td>If <tt class="docutils literal">x</tt> contains an element <em>b</em>
whose <a class="reference internal" href="#kw">keyword</a> is the same as
<tt class="docutils literal">u</tt>'s, returns <em>b</em>'s <em>value</em> (by
reference).  Otherwise, returns <tt class="docutils literal">u</tt>'s
<em>value</em>.</td>
</tr>
<tr><td><tt class="docutils literal">x[w]</tt></td>
<td><tt class="docutils literal">lazy_binding&lt;A,M,E&gt;::type</tt></td>
<td><em>none</em></td>
<td>If <tt class="docutils literal">x</tt> contains an element <em>b</em>
whose <a class="reference internal" href="#kw">keyword</a> is the same as
<tt class="docutils literal">w</tt>'s, returns <em>b</em>'s <em>value</em> (by
reference).  Otherwise, invokes <tt class="docutils literal">w</tt>'s
<em>value</em> and returns the result.</td>
</tr>
<tr><td><tt class="docutils literal">x, z</tt></td>
<td>Model of <span class="concept">ArgumentPack</span></td>
<td><em>none</em></td>
<td>Returns an <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> containing all the elements of both
<tt class="docutils literal">x</tt> and
<tt class="docutils literal">z</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id5">
<span id="parameterspec"></span><h2><a class="toc-backref" href="#id38"
>3.2&nbsp;&nbsp;&nbsp;<span class="concept">ParameterSpec</span></a></h2>
<p>A <span class="concept">ParameterSpec</span> describes the type
requirements for arguments corresponding to a given
<a class="reference internal" href="#kw">keyword</a> and indicates whether the
argument is optional or required.  The table below details the allowed forms
and describes their condition for satisfaction by an actual argument type.  In
each row,</p>
<ul class="simple" id="conditions">
<li><tt class="docutils literal">K</tt> is the <span class="concept"
>ParameterSpec</span>'s <a class="reference internal" href="#keyword-tag-type"
>keyword tag type</a></li>
<li><tt class="docutils literal">A</tt> is an <a class="reference internal"
href="#intended-argument-type">intended argument type</a> associated with
<tt class="docutils literal">K</tt>, if any</li>
<li><tt class="docutils literal">P</tt> is a model of
<a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> that contains
<tt class="docutils literal">A</tt></li>
<li><tt class="docutils literal">F</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a></li>
</ul>
<table border="1" class="docutils">
<caption><span class="concept">ParameterSpec</span> allowed forms and
conditions of satisfaction</caption>
<colgroup>
<col width="32%" />
<col width="21%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr>
<th class="head">Type</th>
<th class="head"><tt class="docutils literal">A</tt> required</th>
<th class="head">Condition <tt class="docutils literal">A</tt> must
satisfy</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td><tt class="docutils literal">K</tt></td>
<td>no</td>
<td><em>n/a</em></td>
</tr>
<tr>
<td><a class="reference internal" href="#optional"><tt
class="docutils literal">optional</tt></a><tt
class="docutils literal">&lt;K,F&gt;</tt></td>
<td>no</td>
<td><tt class="docutils literal"><span
class="pre">mpl::apply2&lt;F,A,P&gt;::type::value</span></tt>
is <tt class="docutils literal">true</tt>.</td>
</tr>
<tr>
<td><a class="reference internal" href="#required"><tt
class="docutils literal">required</tt></a><tt
class="docutils literal">&lt;K,F&gt;</tt></td>
<td>yes</td>
<td><tt class="docutils literal"><span
class="pre">mpl::apply2&lt;F,A,P&gt;::type::value</span></tt>
is <tt class="docutils literal">true</tt>.</td>
</tr>
</tbody>
</table>
<p>The information in a <span class="concept">ParameterSpec</span> is used to
<a class="reference external"
href="index.html#controlling-overload-resolution">limit</a> the arguments that
will be matched by <a class="reference external"
href="index.html#forwarding-functions">forwarding functions</a>.</p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="class-templates">
<h1><a class="toc-backref" href="#id39">4&nbsp;&nbsp;&nbsp;Class
Templates</a></h1>
<div class="section" id="id7">
<span id="keyword"></span><h2><a class="toc-backref" href="#id40"
>4.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal">keyword</tt></a></h2>
<p>The type of every <a class="reference internal" href="#keyword-object"
>keyword object</a> is a specialization of <tt class="docutils literal"
>keyword</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th><td class="field-body"><a
class="reference external" href="../../../../boost/parameter/keyword.hpp"
>boost/parameter/keyword.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename Tag&gt;
struct keyword
{
    typedef Tag tag;

    constexpr keyword()
    {
    }

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_scalar.html"
>is_scalar</a>&lt;T&gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::in_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
        &gt;::type
      , <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a>
    &gt;::type
        <a class="reference internal"
href="#operator">operator=</a>(T const&amp; value) const;

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::out_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_const.html"
>is_const</a>&lt;T&gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
            &gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
        &gt;::type
      , <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a>
    &gt;::type
        <a class="reference internal"
href="#operator">operator=</a>(T&amp; value) const;

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_scalar.html"
>is_scalar</a>&lt;T&gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::in_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
        &gt;::type
      , <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a>
    &gt;::type
        <a class="reference internal"
href="#operator">operator=</a>(T const&amp;&amp; value) const;

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_scalar.html"
>is_scalar</a>&lt;T&gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::consume_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
        &gt;::type
      , <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a>
    &gt;::type
        <a class="reference internal"
href="#operator">operator=</a>(T&amp;&amp; value) const;

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_scalar.html"
>is_scalar</a>&lt;T&gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::in_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
        &gt;::type
      , <em>tagged default</em>
    &gt;::type
        <a class="reference internal"
href="#id9">operator|</a>(T const&amp; x) const;

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::out_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html"><tt
class="docutils literal">if_</tt></a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_const.html"
>is_const</a>&lt;T&gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
            &gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
        &gt;::type
      , <em>tagged default</em>
    &gt;::type
        <a class="reference internal"
href="#id9">operator|</a>(T&amp; x) const;

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_scalar.html"
>is_scalar</a>&lt;T&gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::in_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
        &gt;::type
      , <em>tagged default</em>
    &gt;::type
        <a class="reference internal"
href="#id9">operator|</a>(T const&amp;&amp; x) const;

    template &lt;typename T&gt;
    constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
        typename boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
            boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_scalar.html"
>is_scalar</a>&lt;T&gt;
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
          , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/eval-if.html">eval_if</a>&lt;
                boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                    typename Tag::qualifier
                  , boost::parameter::consume_reference
                &gt;
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
              , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/if.html">if_</a>&lt;
                    boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_same.html"
>is_same</a>&lt;
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    &gt;
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">true_</a>
                  , boost::mpl::<a class="reference external"
href="../../../mpl/doc/refmanual/bool.html">false_</a>
                &gt;
            &gt;
        &gt;::type
      , <em>tagged default</em>
    &gt;::type
        <a class="reference internal"
href="#id9">operator|</a>(T&amp;&amp; x) const;

    template &lt;typename F&gt;
    constexpr <em>tagged lazy default</em> <a class="reference internal"
href="#id10">operator||</a>(F const&amp;) const;

    template &lt;typename F&gt;
    constexpr <em>tagged lazy default</em> <a class="reference internal"
href="#id10">operator||</a>(F&amp;) const;

    static keyword&lt;Tag&gt; const&amp; <a class="reference internal"
href="#instance">instance</a>;

    static keyword&lt;Tag&gt;&amp; <a class="reference internal"
href="#get">get</a>();
};
</pre>
<dl class="docutils" id="operator">
<dt><tt class="docutils literal">operator=</tt></dt>
<dd>
<pre class="first literal-block">
template &lt;typename T&gt;
constexpr <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> operator=(T const&amp; value) const;

template &lt;typename T&gt;
constexpr <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> operator=(T&amp; value) const;

template &lt;typename T&gt;
constexpr <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a
> operator=(T const&amp;&amp; value) const;

template &lt;typename T&gt;
constexpr <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> operator=(T&amp;&amp; value) const;
</pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">one of the following:
<ul>
<li>The nested <tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">forward_reference</tt>.</li>
<li>To use the <tt class="docutils literal">const</tt> lvalue reference
overload, <tt class="docutils literal">T</tt> must be scalar, or the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">in_reference</tt>.</li>
<li>To use the mutable lvalue reference overload, the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">out_reference</tt> or
<tt class="docutils literal">in_out_reference</tt>, and
<tt class="docutils literal">T</tt> must not be
<tt class="docutils literal">const</tt>-qualified.</li>
<li>To use the <tt class="docutils literal">const</tt> rvalue reference
overload for non-scalar <tt class="docutils literal">T</tt>, the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">in_reference</tt>.</li>
<li>To use the mutable rvalue reference overload for non-scalar
<tt class="docutils literal">T</tt>, the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">consume_reference</tt> or
<tt class="docutils literal">move_from_reference</tt>.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">an <a class="reference internal"
href="#argumentpack"><span class="concept">ArgumentPack</span></a> containing
a single <a class="reference internal" href="#tagged-reference">tagged
reference</a> to <tt class="docutils literal">value</tt> with
<a class="reference internal" href="#kw">keyword</a>
<tt class="docutils literal">Tag</tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="docutils" id="id9">
<dt><tt class="docutils literal">operator|</tt></dt>
<dd><pre class="first literal-block">
template &lt;typename T&gt;
constexpr <em>tagged default</em> operator|(T const&amp; x) const;

template &lt;typename T&gt;
constexpr <em>tagged default</em> operator|(T&amp; x) const;

template &lt;typename T&gt;
constexpr <em>tagged default</em> operator|(T const&amp;&amp; x) const;

template &lt;typename T&gt;
constexpr <em>tagged default</em> operator|(T&amp;&amp; x) const;
</pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">one of the following:
<ul>
<li>The nested <tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">forward_reference</tt>.</li>
<li>To use the <tt class="docutils literal">const</tt> lvalue reference
overload, <tt class="docutils literal">T</tt> must be scalar, or the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">in_reference</tt>.</li>
<li>To use the mutable lvalue reference overload, the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">out_reference</tt> or
<tt class="docutils literal">in_out_reference</tt>, and
<tt class="docutils literal">T</tt> must not be
<tt class="docutils literal">const</tt>-qualified.</li>
<li>To use the <tt class="docutils literal">const</tt> rvalue reference
overload for non-scalar <tt class="docutils literal">T</tt>, the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">in_reference</tt>.</li>
<li>To use the mutable rvalue reference overload for non-scalar
<tt class="docutils literal">T</tt>, the nested
<tt class="docutils literal">qualifier</tt> type of
<tt class="docutils literal">Tag</tt> must be
<tt class="docutils literal">consume_reference</tt> or
<tt class="docutils literal">move_from_reference</tt>.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">a <a class="reference internal"
href="#tagged-default">tagged default</a> with <em>value</em>
<tt class="docutils literal">x</tt> and
<a class="reference internal" href="#kw">keyword</a>
<tt class="docutils literal">Tag</tt>.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="docutils" id="id10">
<dt><tt class="docutils literal">operator||</tt></dt>
<dd>
<pre class="first literal-block">
template &lt;typename F&gt;
constexpr <em>tagged lazy default</em> operator||(F const&amp; g) const;

template &lt;typename F&gt;
constexpr <em>tagged lazy default</em> operator||(F&amp; g) const;
</pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body"><tt class="docutils literal">g()</tt> is valid, with
type <tt class="docutils literal">boost::</tt><a class="reference external"
href="../../../utility/utility.htm#result_of"><tt class="docutils literal"
>result_of</tt></a><tt class="docutils literal"><span class="pre"
>&lt;F()&gt;::type</span></tt>.<a class="footnote-reference"
href="#no-result-of" id="id11"><sup>2</sup></a></td>
</tr>
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">a <a class="reference internal"
href="#tagged-lazy-default">tagged lazy default</a> with <em>value</em>
<tt class="docutils literal">g</tt> and <a class="reference internal"
href="#kw">keyword</a> <tt class="docutils literal">Tag</tt>.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="docutils" id="instance">
<dt><tt class="docutils literal">instance</tt></dt>
<dd><pre class="first literal-block">
static keyword&lt;Tag&gt; const&amp; instance;
</pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">a “singleton instance”: the same object will be
returned on each invocation of
<tt class="docutils literal">instance</tt>.</td>
</tr>
<tr class="field">
<th class="field-name">Thread Safety:</th>
<td class="field-body"><tt class="docutils literal">instance</tt> can be
accessed from multiple threads simultaneously.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="docutils" id="get">
<dt><tt class="docutils literal">get</tt></dt>
<dd><pre class="first literal-block">
static keyword&lt;Tag&gt;&amp; get();
</pre>
<div class="admonition-deprecated admonition">
<p class="first admonition-title">Deprecated</p>
<p class="last">This function has been deprecated in favor of
<tt class="docutils literal">instance</tt>.</p>
</div>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">a “singleton instance”: the same object will be
returned on each invocation of
<tt class="docutils literal">get()</tt>.</td>
</tr>
<tr class="field">
<th class="field-name">Thread Safety:</th>
<td class="field-body"><tt class="docutils literal">get()</tt> can be called
from multiple threads simultaneously.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section" id="template-keyword">
<h2><a class="toc-backref" href="#id41">4.2&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">template_keyword</tt></a></h2>
<p>This class template encapsulates a named template parameter.  Every type
generated by the <a class="reference internal"
href="#boost-parameter-template-keyword-name"><tt class="docutils literal"
>BOOST_PARAMETER_TEMPLATE_KEYWORD</tt></a> macro is a specialization of
<tt class="docutils literal">template_keyword</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/template_keyword.hpp"
>boost/parameter/template_keyword.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename Tag, typename T&gt
struct template_keyword
{
    typedef Tag key_type;
    typedef T value_type;
    typedef <em>implementation defined</em> reference;
};
</pre>
<p>The <a class="reference external" href="../../test/ntp.cpp"
>test/ntp.cpp</a> test program demonstrates proper usage of this class
template.</p>
</div>
<div class="section" id="parameters">
<h2><a class="toc-backref" href="#id42">4.3&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">parameters</tt></a></h2>
<p>Provides an interface for assembling the actual arguments to a
<cite>forwarding function</cite> into an <span class="concept"
>ArgumentPack</span>, in which any <a class="reference internal"
href="#positional">positional</a> arguments will be tagged according to the
corresponding template argument to <tt class="docutils literal"
>parameters</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/parameters.hpp"
>boost/parameter/parameters.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename ...PSpec&gt;
struct parameters
{
    template &lt;typename ...Args&gt;
    struct <a class="reference internal" href="#match">match</a>
    {
        typedef … type;
    };

    template &lt;typename ...Args&gt;
    <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> <a class="reference internal"
href="#id13">operator()</a>(Args&amp;&amp;... args) const;
};
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">Each element in the <tt class="docutils literal"
>PSpec</tt> parameter pack must be a model of <a class="reference internal"
href="#parameterspec"><span class="concept">ParameterSpec</span></a>.</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p>In this section, <tt class="docutils literal">R</tt> ## <em>i</em> and
<tt class="docutils literal">K</tt> ## <em>i</em> are defined as follows: for
any argument type <tt class="docutils literal">A</tt> ## <em>i</em>:</p>
<blockquote class="last">
<div class="line-block">
<div class="line">let <tt class="docutils literal">D0</tt> the set [d0, …, d
## <em>j</em>] of all <strong>deduced</strong> <em>parameter specs</em> in
the <tt class="docutils literal">PSpec</tt> parameter pack</div>
<div class="line"><tt class="docutils literal">R</tt> ## <em>i</em> is the
<a class="reference internal" href="#intended-argument-type">intended argument
type</a> of <tt class="docutils literal">A</tt> ## <em>i</em></div>
<div class="line"><br /></div>
<div class="line">if <tt class="docutils literal">A</tt> ## <em>i</em> is a
result type of <tt class="docutils literal"><span class="pre"
>keyword&lt;T&gt;::</span></tt><a class="reference internal" href="#operator"
><tt class="docutils literal">operator=</tt></a></div>
<div class="line">then</div>
<div class="line-block">
<div class="line"><tt class="docutils literal">K</tt> ## <em>i</em> is
<tt class="docutils literal">T</tt></div>
</div>
<div class="line">else</div>
<div class="line-block">
<div class="line">if some <tt class="docutils literal">A</tt> ## <em>j</em>
where <em>j</em> ≤ <em>i</em> is a result type of <tt class="docutils literal"
><span class="pre">keyword&lt;T&gt;::</span></tt><a class="reference internal"
href="#operator"><tt class="docutils literal">operator=</tt></a></div>
<div class="line"><em>or</em> some <tt class="docutils literal">P</tt> ##
<em>j</em> in <em>j</em> ≤ <em>i</em> is <strong>deduced</strong></div>
<div class="line">then</div>
<div class="line-block">
<div class="line">if some <em>parameter spec</em> <tt class="docutils literal"
>d</tt><em>j</em> in <tt class="docutils literal">D</tt> ## <em>i</em> matches
<tt class="docutils literal">A</tt><em>i</em></div>
<div class="line">then</div>
<div class="line-block">
<div class="line"><tt class="docutils literal">K</tt> ## <em>i</em> is <tt
class="docutils literal">d</tt> ## <em>j</em>'s <a class="reference internal"
href="#keyword-tag-type">keyword tag type</a>.</div>
<div class="line"><tt class="docutils literal">D</tt><sub>i+1</sub> is
<tt class="docutils literal">D</tt> ## <em>i</em> -
[<tt class="docutils literal">d</tt> ## <em>j</em>]</div>
</div>
</div>
<div class="line">else</div>
<div class="line-block">
<div class="line"><tt class="docutils literal">K</tt> ## <em>i</em> is <tt
class="docutils literal">P</tt> ## <em>i</em>'s <a class="reference internal"
href="#keyword-tag-type">keyword tag type</a>.</div>
</div>
</div>
</div>
</blockquote>
</div>
<dl class="docutils" id="match">
<dt><tt class="docutils literal">match</tt></dt>
<dd>
<p class="first">A <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept"
>Metafunction</span></a> used to remove a <a class="reference external"
href="index.html#forwarding-functions">forwarding function</a> from overload
resolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">if all elements in
<tt class="docutils literal">Params...</tt> are <em>satisfied</em> (see
below), then <tt class="docutils literal"><span
class="pre">parameters&lt;Params...&gt;</span></tt>.  Otherwise,
<tt class="docutils literal"><span
class="pre">match&lt;Args...&gt;::type</span></tt> is not defined.</td>
</tr>
</tbody>
</table>
<p>Each element <tt class="docutils literal">P</tt> in
<tt class="docutils literal">Params</tt> is <strong>satisfied</strong> if
either:</p>
<ul class="last simple">
<li><tt class="docutils literal">P</tt> is the <em>unspecified</em>
default</li>
<li><strong>or</strong>, <tt class="docutils literal">P</tt> is a
<em>keyword tag type</em></li>
<li><strong>or</strong>, <tt class="docutils literal">P</tt> is
<a class="reference internal" href="#optional"><tt class="docutils literal"
>optional</tt></a><tt class="docutils literal">&lt;X,F&gt;</tt> and either
<ul>
<li><tt class="docutils literal">X</tt> is not <tt class="docutils literal"
>K</tt> ## <em>i</em> for any <em>i</em>,</li>
<li><strong>or</strong> <tt class="docutils literal">X</tt> is some
<tt class="docutils literal">K</tt> ## <em>i</em> and
<tt class="docutils literal"><span class="pre">mpl::apply&lt;F,R</span></tt>
## <em>i</em><tt class="docutils literal"><span class="pre"
>&gt;::type::value</span></tt> is <tt class="docutils literal">true</tt></li>
</ul>
</li>
<li><strong>or</strong>, <tt class="docutils literal">P</tt> is
<a class="reference internal" href="#required"><tt class="docutils literal"
>required</tt></a><tt class="docutils literal">&lt;X,F&gt;</tt>, and
<ul>
<li><tt class="docutils literal">X</tt> is some <tt class="docutils literal"
>K</tt> ## <em>i</em>, <strong>and</strong></li>
<li><tt class="docutils literal"><span class="pre"
>mpl::apply&lt;F,R</span></tt> ## <em>i</em><tt class="docutils literal"
><span class="pre">&gt;::type::value</span></tt> is
<tt class="docutils literal">true</tt></li>
</ul>
</li>
</ul>
</dd>
</dl>
<dl class="docutils" id="id13">
<dt><tt class="docutils literal">operator()</tt></dt>
<dd>
<pre class="first literal-block">
template &lt;typename ...Args&gt;
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a> operator()(Args&amp;&amp;... args) const;
</pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body"><p class="first">An <a class="reference internal"
href="#argumentpack"><span class="concept">ArgumentPack</span></a>
containing, for each <tt class="docutils literal">a</tt> ## <em>i</em>,</p>
<ul class="last simple">
<li>if <tt class="docutils literal">a</tt> ## <em>i</em> is a single-element
<span class="concept">ArgumentPack</span>, its element</li>
<li>Otherwise, a <a class="reference internal" href="#tagged-reference">tagged
reference</a> with <a class="reference internal" href="#kw">keyword</a>
<tt class="docutils literal">K</tt> ## <em>i</em> and <em>value</em>
<tt class="docutils literal">a</tt> ## <em>i</em></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section" id="optional-required">
<span id="required"></span><span id="optional"></span><h2><a
class="toc-backref" href="#id43">4.4&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">optional</tt>, <tt class="docutils literal"
>required</tt></a></h2>
<p>These templates describe the requirements on a function parameter.</p>
<p><tt class="docutils literal">optional</tt> is defined in: <a
class="reference external" href="../../../../boost/parameter/optional.hpp"
>boost/parameter/optional.hpp</a>.</p>
<p><tt class="docutils literal">required</tt> is defined in: <a
class="reference external" href="../../../../boost/parameter/required.hpp"
>boost/parameter/required.hpp</a>.</p>
<p>Both headers are included by: <a class="reference external"
href="../../../../boost/parameter/parameters.hpp"
>boost/parameter/parameters.hpp</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Specializations model:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body"><a class="reference internal" href="#parameterspec"
><span class="concept">ParameterSpec</span></a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename Tag, typename Predicate = <em>unspecified</em>&gt;
struct optional;

template &lt;typename Tag, typename Predicate = <em>unspecified</em>&gt;
struct required;
</pre>
<p>The default value of <tt class="docutils literal">Predicate</tt> is an
unspecified <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> that returns <tt class="docutils literal"
>mpl::true_</tt> for any argument.  If <a class="reference internal"
href="#boost-parameter-can-use-mp11"><tt class="docutils literal"
>BOOST_PARAMETER_CAN_USE_MP11</tt></a> is defined, then the default value of
<tt class="docutils literal">Predicate</tt> is also a <a
class="reference external" href="../../../mp11/doc/html/mp11.html"
>Boost.MP11</a>-style that returns <tt class="docutils literal"
>mp11::mp_true</tt> for any argument.</p>
</div>
<div class="section" id="deduced">
<h2><a class="toc-backref" href="#id44">4.5&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">deduced</tt></a></h2>
<p>This template is used to wrap the <em>keyword tag</em> argument to
<tt class="docutils literal">optional</tt> or <tt class="docutils literal"
>required</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/deduced.hpp"
>boost/parameter/deduced.hpp</a></td>
</tr>
<tr class="field">
<th class="field-name">Included by:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/parameters.hpp"
>boost/parameter/parameters.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename Tag&gt;
struct deduced;
</pre>
</div>
</div>
<hr class="docutils" />
<div class="section" id="metafunctions">
<h1><a class="toc-backref" href="#id45"
>5&nbsp;&nbsp;&nbsp;Metafunctions</a></h1>
<p>A <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept"
>Metafunction</span></a> is conceptually a function that operates on, and
returns, C++ types.</p>
<div class="section" id="binding">
<h2><a class="toc-backref" href="#id46">5.1&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">binding</tt></a></h2>
<p>Returns the result type of indexing an argument pack with a
<a class="reference internal" href="#keyword-tag-type">keyword tag type</a> or
with a <a class="reference internal" href="#tagged-default">tagged
default</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/binding.hpp"
>boost/parameter/binding.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename A, typename K, typename D = void_&gt;
struct binding
{
    typedef … type;
};
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body"><tt class="docutils literal">A</tt> is a model of
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a>.</td>
</tr>
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">the reference type of the <a class="reference internal"
href="#tagged-reference">tagged reference</a> in <tt class="docutils literal"
>A</tt> having <a class="reference internal" href="#keyword-tag-type">keyword
tag type</a> <tt class="docutils literal">K</tt>, if any.  If no such
<a class="reference internal" href="#tagged-reference">tagged reference</a>
exists, returns <tt class="docutils literal">D</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="lazy-binding">
<h2><a class="toc-backref" href="#id47">5.2&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">lazy_binding</tt></a></h2>
<p>Returns the result type of indexing an argument pack with a
<a class="reference internal" href="#tagged-lazy-default">tagged lazy
default</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/binding.hpp"
>boost/parameter/binding.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename A, typename K, typename F&gt;
struct lazy_binding
{
    typedef … type;
};
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body"><tt class="docutils literal">A</tt> is a model of
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a>.</td>
</tr>
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">the reference type of the <a class="reference internal"
href="#tagged-reference">tagged reference</a> in <tt class="docutils literal"
>A</tt> having <a class="reference internal" href="#keyword-tag-type">keyword
tag type</a> <tt class="docutils literal">K</tt>, if any.  If no such
<a class="reference internal" href="#tagged-reference">tagged reference</a>
exists, returns <tt class="docutils literal">boost::</tt><a
class="reference external" href="../../../utility/utility.htm#result_of"
><tt class="docutils literal">result_of</tt></a><tt class="docutils literal"
><span class="pre">&lt;F()&gt;::type</span></tt>.<a class="footnote-reference"
href="#no-result-of" id="id18"><sup>2</sup></a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="value-type">
<h2><a class="toc-backref" href="#id48">5.3&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">value_type</tt></a></h2>
<p>Returns the result type of indexing an argument pack with a
<a class="reference internal" href="#keyword-tag-type">keyword tag type</a> or
with a <a class="reference internal" href="#tagged-default">tagged
default</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined n:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/value_type.hpp"
>boost/parameter/value_type.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename A, typename K, typename D = void_&gt;
struct value_type
{
    typedef … type;
};
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">
<p class="first"><tt class="docutils literal">A</tt> is a model of
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a>.</p>
</td>
</tr>
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">the type of the <a class="reference internal"
href="#tagged-reference">tagged reference</a> in <tt class="docutils literal"
>A</tt> having <a class="reference internal" href="#keyword-tag-type">keyword
tag type</a> <tt class="docutils literal">K</tt>, if any.  If no such
<a class="reference internal" href="#tagged-reference">tagged reference</a>
exists, returns <tt class="docutils literal">D</tt>.  Equivalent to:</p>
<pre class="literal-block">
typename boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/remove_reference.html"
>remove_reference</a>&lt;
    typename <a class="reference internal" href="#binding"
>binding</a>&lt;A, K, D&gt;::type
&gt;::type
</pre>
<p class="last">… when <tt class="docutils literal">D</tt> is not a reference
type.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="are-tagged-arguments">
<h2><a class="toc-backref" href="#id49">5.4&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">are_tagged_arguments</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/are_tagged_arguments.hpp"
>boost/parameter/are_tagged_arguments.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename T0, typename ...Pack&gt;
struct are_tagged_arguments  // : mpl::true_ or mpl::false_
{
};
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Returns:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body"><tt class="docutils literal">mpl::true_</tt> if <tt
class="docutils literal">T0</tt> and all elements in parameter pack <tt
class="docutils literal">Pack</tt> are <a class="reference internal"
href="#tagged-reference">tagged reference</a> types, <tt
class="docutils literal">mpl::false_</tt> otherwise.</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p class="first">When implementing a Boost.Parameter-enabled constructor for a
container that conforms to the C++ standard, one needs to remember that the
standard requires the presence of other constructors that are typically
defined as templates, such as range constructors.  To avoid overload
ambiguities between the two constructors, use this metafunction in conjunction
with <tt class="docutils literal">disable_if</tt> to define the range
constructor.</p>
<pre class="first literal-block">
template &lt;typename B&gt;
class frontend : public B
{
    struct _enabler
    {
    };

 public:
    <a class="reference internal"
href="#boost-parameter-no-spec-constructor-cls-impl"
>BOOST_PARAMETER_NO_SPEC_CONSTRUCTOR</a>(frontend, (B))

    template &lt;typename Iterator&gt;
    frontend(
        Iterator itr
      , Iterator itr_end
      , typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">disable_if</a>&lt;
            are_tagged_arguments&lt;Iterator&gt;
          , _enabler
        &gt;::type = _enabler()
    ) : B(itr, itr_end)
    {
    }
};
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="is-argument-pack">
<h2><a class="toc-backref" href="#id51">5.5&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">is_argument_pack</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/is_argument_pack.hpp"
>boost/parameter/is_argument_pack.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
template &lt;typename T&gt;
struct is_argument_pack  // : mpl::true_ or mpl::false_
{
};
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Returns:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body"><tt class="docutils literal">mpl::true_</tt> if <tt
class="docutils literal">T</tt> is a model of <a class="reference internal"
href="#argumentpack"><span class="concept">ArgumentPack</span></a>, <tt
class="docutils literal">mpl::false_</tt> otherwise.</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p class="first">To avoid overload ambiguities between a constructor that
takes in an <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> and a templated conversion
constructor, use this metafunction in conjunction with <tt
class="docutils literal">enable_if</tt>.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a0)

template &lt;typename T&gt;
class backend0
{
    struct _enabler
    {
    };

    T a0;

 public:
    template &lt;typename ArgPack&gt;
    explicit backend0(
        ArgPack const&amp; args
      , typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
            is_argument_pack&lt;ArgPack&gt;
          , _enabler
        &gt;::type = _enabler()
    ) : a0(args[_a0])
    {
    }

    template &lt;typename U&gt;
    backend0(
        backend0&lt;U&gt; const&amp; copy
      , typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
            boost::<a class="reference external"
href="../../../type_traits/doc/html/boost_typetraits/is_convertible.html"
>is_convertible</a>&lt;U,T&gt;
          , _enabler
        &gt;::type = _enabler()
    ) : a0(copy.get_a0())
    {
    }

    T const&amp; get_a0() const
    {
        return this-&gt;a0;
    }
};
</pre>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<hr class="docutils" />
<div class="section" id="function-templates">
<h1><a class="toc-backref" href="#id53">6&nbsp;&nbsp;&nbsp;Function
Templates</a></h1>
<div class="section" id="compose">
<h2><a class="toc-backref" href="#id54">6.1&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">compose</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/compose.hpp"
>boost/parameter/compose.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">
constexpr <em>empty</em> <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a> compose();

template &lt;typename T0, typename ...Pack&gt;
constexpr typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
    <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;T0,Pack...&gt;
  , <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a>
&gt;::type
    compose(T0 const&amp; t0, Pack const&amp;... args);
</pre>
<p>This function facilitates easier variadic argument composition.  It is used
by the <a class="reference internal"
href="#boost-parameter-no-spec-function-result-name"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_FUNCTION</tt></a>, <a
class="reference internal"
href="#boost-parameter-no-spec-member-function-result-name"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_MEMBER_FUNCTION</tt></a>, <a
class="reference internal"
href="#boost-parameter-no-spec-c-mem-function-result-name"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_CONST_MEMBER_FUNCTION</tt></a
>, <a class="reference internal"
href="#boost-parameter-no-spec-function-call-op-result"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_FUNCTION_CALL_OPERATOR</tt
></a>, <a class="reference internal"
href="#boost-parameter-no-spec-const-func-call-op-result"><tt
class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_CONST_FUNCTION_CALL_OPERATOR</tt></a>, <a
class="reference internal"
href="#boost-parameter-no-spec-constructor-cls-impl"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_CONSTRUCTOR</tt></a>, and <a
class="reference internal"
href="#boost-parameter-no-spec-no-base-ctor-cls-func"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_NO_BASE_CONSTRUCTOR</tt></a>
code generation macros.  You can use it to write your own code generation
macros if the ones provided by this library do not suffice.</p>
<p>Unlike the <a class="reference internal" href="#tagged-reference">tagged
reference</a> comma operator, the <tt class="docutils literal">compose()</tt>
function is variadic, as mentioned before.  However, the <a
class="reference internal" href="#tagged-reference">tagged reference</a> comma
operator can be invoked indefinitely and therefore does not limit the size of
the resulting <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a>, while the <tt
class="docutils literal">compose()</tt> function cannot take in more than <a
class="reference internal" href="#boost-parameter-compose-max-arity"><tt
class="docutils literal">BOOST_PARAMETER_COMPOSE_MAX_ARITY</tt></a> arguments
for compilers that do not support perfect forwarding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">
<p class="first"><tt class="docutils literal">t0</tt> and all elements in <tt
class="docutils literal">args</tt> must be <a class="reference internal"
href="#tagged-reference">tagged reference</a> objects, if specified.</p>
</td>
</tr>
<tr class="field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">An <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> containing <tt
class="docutils literal">t0</tt> and all elements in <tt
class="docutils literal">args</tt>, if specified; an empty <a
class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a> otherwise.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td class="field-body" colspan="2">
<pre class="literal-block">
BOOST_PARAMETER_NAME(name)

template &lt;typename ArgumentPack&gt;
int print_name_and_index(ArgumentPack const&amp; args)
{
    std::cout &lt;&lt; &quot;index = &quot; &lt;&lt; args[_index];
    std::cout &lt;&lt; &quot;name = &quot; &lt;&lt; args[_name];
    std::cout &lt;&lt; &quot;; &quot; &lt;&lt; std::endl;
    return 0;
}

int y = print_name_and_index(compose(_index = 3, _name = &quot;jones&quot;));
</pre>
<p>The <a class="reference external" href="../../test/compose.cpp"
>test/compose.cpp</a> test program shows more examples using this
function.</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<hr class="docutils" />
<div class="section" id="code-generation-macros">
<h1><a class="toc-backref" href="#id55">7&nbsp;&nbsp;&nbsp;Code Generation
Macros</a></h1>
<p>Macros in this section can be used to ease the writing of code using the
Parameter libray by eliminating repetitive boilerplate.</p>
<div class="section"
id="boost-parameter-function-result-name-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id56">7.1&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_FUNCTION(result, name, tag_namespace,
arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function that can take in positional arguments, composed
arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will be
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal function header.  Enclose the
return type <tt class="docutils literal">bool</tt> in parentheses.  For each
parameter, also enclose the expected value type in parentheses.  Since the
value types are mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  Also, just as with a normal function, optional parameters
have default values, whereas required parameters do not.  Within the function
body, either simply use the parameter name or pass the matching identifier
with the leading underscore to the bracket operator of <tt
class="docutils literal">args</tt> to extract the corresponding
argument.  Note that the second method doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
BOOST_PARAMETER_FUNCTION((bool), evaluate, kw,
    (deduced
        (required
            (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
            (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
        )
        (optional
            (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;), rvalue_const_bitset&lt;2&gt;())
            (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;), rvalue_bitset&lt;3&gt;())
        )
    )
)
{
    BOOST_TEST_EQ(
        passed_by_lvalue_reference_to_const
      , U::evaluate_category&lt;0&gt;(lrc)
    );
    BOOST_TEST_EQ(
        passed_by_lvalue_reference
      , U::evaluate_category&lt;1&gt;(lr)
    );
    BOOST_TEST_EQ(
        passed_by_rvalue_reference_to_const
      , U::evaluate_category&lt;2&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;rrc0_type&gt;(rrc0))
    );
    BOOST_TEST_EQ(
        passed_by_rvalue_reference
      , U::evaluate_category&lt;3&gt;(args[_rr0])
    );

    return true;
}
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
evaluate((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
evaluate(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
evaluate(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
evaluate(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
evaluate(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a>, <a class="reference external"
href="../../test/preprocessor_deduced.cpp">test/preprocessor_deduced.cpp</a>,
and <a class="reference external"
href="../../test/preprocessor_eval_category.cpp"
>test/preprocessor_eval_category.cpp</a> test programs demonstrate proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated forwarding functions.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>optional-specifier</em> {<em>optional-specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>required-specifier</em> {<em>required-specifier</em>}
        '<strong>)</strong>'
    )

optional-specifier ::=
    '<strong>(</strong>'
        <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> '<strong>,</strong>' <em>default-value</em>
    ')'

required-specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">default-value</tt> is any valid C++
expression; if necessary, user code can compute it in terms of
<tt class="docutils literal">previous-name ## _type</tt>, where
<tt class="docutils literal">previous-name</tt> is the
<tt class="docutils literal">argument-name</tt> in a previous
<tt class="docutils literal">specifier-group0</tt> or
<tt class="docutils literal">specifier-group1</tt>.  <em>This expression will
be invoked exactly once.</em></li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.  If <tt class="docutils literal"
>restriction</tt> uses this form, then the type of the generated name <tt
class="docutils literal">argument-name ## _type</tt> will be computed in terms
of the <strong>target type</strong>, and the generated reference
<tt class="docutils literal">argument-name</tt> (but not its corresponding
entry in <tt class="docutils literal">args</tt>) will be cast to that
type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_ ## __LINE__ ## <strong>name</strong>
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_ ## __LINE__ ## <strong>name</strong>
    boost_param_parameters_ ## __LINE__ ## <strong>name</strong>;

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## <strong
>name</strong> ## _&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## <strong>name</strong>(Args const&amp;);

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>
        ::match&lt;A0, …, A ## <strong>n</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>()
    )
{
    return boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>
        ::match&lt;A0, …, A ## <strong>m</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>()
    )
{
    return boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>n</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>n</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>n</strong>
    );

<span class="vellipsis">⋮</span>

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>m</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>m</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>m</strong>
    );

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## <strong
>name</strong>&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## <strong>name</strong>(Args const& args)
{
    return boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        static_cast&lt;
            typename boost_param_result_ ## __LINE__ ## <strong
>name</strong>&lt;
                Args
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , args
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>0</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>0</strong>])
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>n</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>n</strong>])
    );
}

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>n</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>n</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>n</strong>
    )
{
    return boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        static_cast&lt;ResultType(*)()&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , (args, <em>keyword object of optional parameter</em> ## <strong
>n + 1</strong> =
            <em>default value of optional parameter</em> ## <strong
>n + 1</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>0</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>0</strong>
        )
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>n</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>n</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of optional parameter</em> ## <strong>n + 1</strong>
            &gt;::type
        &gt;(<em>default value of optional parameter</em> ## <strong
>n + 1</strong>)
    );
}

<span class="vellipsis">⋮</span>

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>m</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>m</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>m</strong>
    )
</pre>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-member-function-result-name-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id57">7.2&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_MEMBER_FUNCTION(result, name,
tag_namespace, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a member function that can take in positional arguments, composed
arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will be
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal <tt class="docutils literal"
>static</tt> member function header.  Enclose the return type <tt
class="docutils literal">bool</tt> in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  Also, just as with a normal function, optional parameters
have default values, whereas required parameters do not.  Within the function
body, either simply use the parameter name or pass the matching identifier
with the leading underscore to the bracket operator of <tt
class="docutils literal">args</tt> to extract the corresponding
argument.  Note that the second method doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
struct B
{
    BOOST_PARAMETER_MEMBER_FUNCTION((bool), static evaluate, kw,
        (deduced
            (required
                (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
                (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
            )
            (optional
                (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;), rvalue_const_bitset&lt;2&gt;())
                (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;), rvalue_bitset&lt;3&gt;())
            )
        )
    )
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(lrc)
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(lr)
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;rrc0_type&gt;(rrc0))
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(args[_rr0])
        );

        return true;
    }
};
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
B::evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
B::evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
B::evaluate((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
B::evaluate(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
B::evaluate(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
B::evaluate(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
B::evaluate(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> and <a class="reference external"
href="../../test/preprocessor_eval_category.cpp"
>test/preprocessor_eval_category.cpp</a> test programs demonstrate proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated forwarding functions.  <tt
class="docutils literal">name</tt> may be qualified by the <tt
class="docutils literal">static</tt> keyword to declare the member function
and its helpers as not associated with any object of the enclosing type.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>optional-specifier</em> {<em>optional-specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>required-specifier</em> {<em>required-specifier</em>}
        '<strong>)</strong>'
    )

optional-specifier ::=
    '<strong>(</strong>'
        <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> '<strong>,</strong>' <em>default-value</em>
    ')'

required-specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">default-value</tt> is any valid C++
expression; if necessary, user code can compute it in terms of
<tt class="docutils literal">previous-name ## _type</tt>, where
<tt class="docutils literal">previous-name</tt> is the
<tt class="docutils literal">argument-name</tt> in a previous
<tt class="docutils literal">specifier-group0</tt> or
<tt class="docutils literal">specifier-group1</tt>.  <em>This expression will
be invoked exactly once.</em></li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.  If <tt class="docutils literal"
>restriction</tt> uses this form, then the type of the generated name <tt
class="docutils literal">argument-name ## _type</tt> will be computed in terms
of the <strong>target type</strong>, and the generated reference
<tt class="docutils literal">argument-name</tt> (but not its corresponding
entry in <tt class="docutils literal">args</tt>) will be cast to that
type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_ ## __LINE__ ## <strong>name</strong>
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_ ## __LINE__ ## <strong>name</strong>
    boost_param_parameters_ ## __LINE__ ## <strong>name</strong>;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong>name</strong>
        ::match&lt;A0, …, A ## <strong>n</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong>name</strong>
        ::match&lt;A0, …, A ## <strong>m</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## <strong
>name</strong>&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## <strong
>name</strong>(Args const&amp; args)
{
    return this-&gt;boost_param_dispatch_0boost_ ## __LINE__ ## <strong
>name</strong>(
        static_cast&lt;
            typename boost_param_result_ ## __LINE__ ## <strong
>name</strong>&lt;
                Args
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , args
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>0</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>0</strong>])
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>n</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>n</strong>])
    );
}

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>n</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>n</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>n</strong>
    )
{
    return this-&gt;boost_param_dispatch_0boost_ ## __LINE__ ## <strong
>name</strong>(
        static_cast&lt;ResultType(*)()&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , (args, <em>keyword object of optional parameter</em> ## <strong
>n + 1</strong> =
            <em>default value of optional parameter</em> ## <strong
>n + 1</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>0</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>0</strong>
        )
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>n</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>n</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of optional parameter</em> ## <strong>n + 1</strong>
            &gt;::type
        &gt;(<em>default value of optional parameter</em> ## <strong
>n + 1</strong>)
    );
}

<span class="vellipsis">⋮</span>

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>m</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>m</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>m</strong>
    )
</pre>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-c-mem-function-result-name-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id58">7.3&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_CONST_MEMBER_FUNCTION(result, name,
tag_namespace, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a member function that can take in positional arguments, composed
arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will be
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal <tt class="docutils literal"
>const</tt> member function header.  Enclose the return type <tt
class="docutils literal">bool</tt> in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  Also, just as with a normal function, optional parameters
have default values, whereas required parameters do not.  Within the function
body, either simply use the parameter name or pass the matching identifier
with the leading underscore to the bracket operator of <tt
class="docutils literal">args</tt> to extract the corresponding
argument.  Note that the second method doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
struct B
{
    B()
    {
    }

    BOOST_PARAMETER_CONST_MEMBER_FUNCTION((bool), evaluate, kw,
        (deduced
            (required
                (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
                (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
            )
            (optional
                (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;), rvalue_const_bitset&lt;2&gt;())
                (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;), rvalue_bitset&lt;3&gt;())
            )
        )
    )
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(lrc)
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(lr)
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;rrc0_type&gt;(rrc0))
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(args[_rr0])
        );

        return true;
    }
};
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
B const b = B();
b.evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
b.evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
b.evaluate((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
b.evaluate(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
b.evaluate(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
b.evaluate(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
b.evaluate(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> test program demonstrates proper usage of this
macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated forwarding functions.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>optional-specifier</em> {<em>optional-specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>required-specifier</em> {<em>required-specifier</em>}
        '<strong>)</strong>'
    )

optional-specifier ::=
    '<strong>(</strong>'
        <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> '<strong>,</strong>' <em>default-value</em>
    ')'

required-specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">default-value</tt> is any valid C++
expression; if necessary, user code can compute it in terms of
<tt class="docutils literal">previous-name ## _type</tt>, where
<tt class="docutils literal">previous-name</tt> is the
<tt class="docutils literal">argument-name</tt> in a previous
<tt class="docutils literal">specifier-group0</tt> or
<tt class="docutils literal">specifier-group1</tt>.  <em>This expression will
be invoked exactly once.</em></li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.  If <tt class="docutils literal"
>restriction</tt> uses this form, then the type of the generated name <tt
class="docutils literal">argument-name ## _type</tt> will be computed in terms
of the <strong>target type</strong>, and the generated reference
<tt class="docutils literal">argument-name</tt> (but not its corresponding
entry in <tt class="docutils literal">args</tt>) will be cast to that
type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_const_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_const_ ## __LINE__ ## <strong>name</strong>
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_const_ ## __LINE__ ## <strong>name</strong>
    boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## <strong
>name</strong>
        ::match&lt;A0, …, A ## <strong>n</strong>&gt;::type
        = boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## <strong
>name</strong>(
        boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## <strong
>name</strong>
        ::match&lt;A0, …, A ## <strong>m</strong>&gt;::type
        = boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## <strong
>name</strong>(
        boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_const_ ## __LINE__ ## <strong
>name</strong>&lt;Args&gt;::type
    boost_param_impl_const ## __LINE__ ## <strong
>name</strong>(Args const&amp; args) const
{
    return this-&gt;
    boost_param_dispatch_const_0boost_ ## __LINE__ ## <strong>name</strong>(
        static_cast&lt;
            typename boost_param_result_const_ ## __LINE__ ## <strong
>name</strong>&lt;
                Args
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , args
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>0</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>0</strong>])
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>n</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>n</strong>])
    );
}

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>n</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_const_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>n</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>n</strong>
    ) const
{
    return this-&gt;
    boost_param_dispatch_const_0boost_ ## __LINE__ ## <strong>name</strong>(
        static_cast&lt;ResultType(*)()&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , (args, <em>keyword object of optional parameter</em> ## <strong
>n + 1</strong> =
            <em>default value of optional parameter</em> ## <strong
>n + 1</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>0</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>0</strong>
        )
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>n</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>n</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of optional parameter</em> ## <strong>n + 1</strong>
            &gt;::type
        &gt;(<em>default value of optional parameter</em> ## <strong
>n + 1</strong>)
    );
}

<span class="vellipsis">⋮</span>

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>m</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_const_0boost_ ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>m</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>m</strong>
    ) const
</pre>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-function-call-op-result-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id59">7.4&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_FUNCTION_CALL_OPERATOR(result,
tag_ns, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function call operator that can take in positional arguments,
composed arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">tag</tt> by default.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(y)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(z)
</pre>
<p>Use the macro as a substitute for a normal function call operator
header.  Enclose the return type in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  This is especially useful
when implementing multiple Boost.Parameter-enabled function call operator
overloads.</p>
<pre class="first literal-block">
class char_reader
{
    int index;
    char const* key;

 public:
    explicit char_reader(char const* k) : index(0), key(k)
    {
    }

    BOOST_PARAMETER_FUNCTION_CALL_OPERATOR((void), tag,
        (deduced
            (required
                (y, (int))
                (z, (char const*))
            )
        )
    )
    {
        this-&gt;index = y;
        this-&gt;key = z;
    }

    <a class="reference internal"
href="#boost-parameter-const-function-call-op-result-tag-namespace-arguments"
>BOOST_PARAMETER_CONST_FUNCTION_CALL_OPERATOR</a>((char), tag,
        (deduced
            (required
                (y, (bool))
                (z, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/container/map"
>map</a>&lt;char const*,std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string">string</a>&gt;))
            )
        )
    )
    {
        return y ? (
            (z.find(this-&gt;key)-&gt;second)[this-&gt;index]
        ) : this-&gt;key[this-&gt;index];
    }
};
</pre>
<p>As with regular argument-dependent lookup, the value types of the arguments
passed in determine which function call operator overload gets invoked.</p>
<pre class="first literal-block">
char const* keys[] = {"foo", "bar", "baz"};
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/container/map"
>map</a>&lt;char const*,std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt; k2s;
k2s[keys[0]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("qux");
k2s[keys[1]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("wmb");
k2s[keys[2]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("zxc");
char_reader r(keys[0]);

// positional arguments
BOOST_TEST_EQ('q', (r(true, k2s)));
BOOST_TEST_EQ('f', (r(false, k2s)));

// named arguments
r(_z = keys[1], _y = 1);
BOOST_TEST_EQ('m', (r(_z = k2s, _y = true)));
BOOST_TEST_EQ('a', (r(_z = k2s, _y = false)));

// deduced arguments
r(keys[2], 2);
BOOST_TEST_EQ('c', (r(k2s, true)));
BOOST_TEST_EQ('z', (r(k2s, false)));
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> and <a class="reference external"
href="../../test/preprocessor_deduced.cpp">test/preprocessor_deduced.cpp</a>
test programs demonstrate proper usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function call operator.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function call operator resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>optional-specifier</em> {<em>optional-specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>required-specifier</em> {<em>required-specifier</em>}
        '<strong>)</strong>'
    )

optional-specifier ::=
    '<strong>(</strong>'
        <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> '<strong>,</strong>' <em>default-value</em>
    ')'

required-specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">default-value</tt> is any valid C++
expression; if necessary, user code can compute it in terms of
<tt class="docutils literal">previous-name ## _type</tt>, where
<tt class="docutils literal">previous-name</tt> is the
<tt class="docutils literal">argument-name</tt> in a previous
<tt class="docutils literal">specifier-group0</tt> or
<tt class="docutils literal">specifier-group1</tt>.  <em>This expression will
be invoked exactly once.</em></li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.  If <tt class="docutils literal"
>restriction</tt> uses this form, then the type of the generated name <tt
class="docutils literal">argument-name ## _type</tt> will be computed in terms
of the <strong>target type</strong>, and the generated reference
<tt class="docutils literal">argument-name</tt> (but not its corresponding
entry in <tt class="docutils literal">args</tt>) will be cast to that
type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_ ## __LINE__ ## operator
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_ ## __LINE__ ## operator
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_ ## __LINE__ ## operator
    boost_param_parameters_ ## __LINE__ ## operator;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>n</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## operator()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## operator(
        boost_param_parameters_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>m</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## operator()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## operator(
        boost_param_parameters_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## operator&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## operator(Args const&amp; args)
{
    return this-&gt;boost_param_dispatch_0boost_ ## __LINE__ ## operator(
        static_cast&lt;
            typename boost_param_result_ ## __LINE__ ## operator&lt;
                Args
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , args
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>0</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>0</strong>])
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>n</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>n</strong>])
    );
}

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>n</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## operator(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>n</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>n</strong>
    )
{
    return this-&gt;boost_param_dispatch_0boost_ ## __LINE__ ## operator(
        static_cast&lt;ResultType(*)()&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , (args, <em>keyword object of optional parameter</em> ## <strong
>n + 1</strong> =
            <em>default value of optional parameter</em> ## <strong
>n + 1</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>0</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>0</strong>
        )
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>n</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>n</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of optional parameter</em> ## <strong>n + 1</strong>
            &gt;::type
        &gt;(<em>default value of optional parameter</em> ## <strong
>n + 1</strong>)
    );
}

<span class="vellipsis">⋮</span>

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>m</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_0boost_ ## __LINE__ ## operator(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>m</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>m</strong>
    )
</pre>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-const-function-call-op-result-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id60">7.5&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_CONST_FUNCTION_CALL_OPERATOR(result,
tag_ns, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function call operator that can take in positional arguments,
composed arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will be
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal <tt class="docutils literal"
>const</tt> function call operator header.  Enclose the return type <tt
class="docutils literal">bool</tt> in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  Also, just as with a normal function, optional parameters
have default values, whereas required parameters do not.  Within the function
body, either simply use the parameter name or pass the matching identifier
with the leading underscore to the bracket operator of <tt
class="docutils literal">args</tt> to extract the corresponding
argument.  Note that the second method doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
struct B
{
    B()
    {
    }

    BOOST_PARAMETER_CONST_FUNCTION_CALL_OPERATOR((bool), kw,
        (deduced
            (required
                (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
                (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
            )
            (optional
                (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;), rvalue_const_bitset&lt;2&gt;())
                (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;), rvalue_bitset&lt;3&gt;())
            )
        )
    )
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(lrc)
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(lr)
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;rrc0_type&gt;(rrc0))
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(args[_rr0])
        );

        return true;
    }
};
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
B const b = B();
b(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
b(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
b((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
b(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
b(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
b(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
b(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a>, <a class="reference external"
href="../../test/preprocessor_deduced.cpp">test/preprocessor_deduced.cpp</a>,
and <a class="reference external"
href="../../test/preprocessor_eval_cat_8.cpp"
>test/preprocessor_eval_cat_8.cpp</a> test programs demonstrate proper usage
of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function call operator.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function call operator resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>optional-specifier</em> {<em>optional-specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>required-specifier</em> {<em>required-specifier</em>}
        '<strong>)</strong>'
    )

optional-specifier ::=
    '<strong>(</strong>'
        <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> '<strong>,</strong>' <em>default-value</em>
    ')'

required-specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">default-value</tt> is any valid C++
expression; if necessary, user code can compute it in terms of
<tt class="docutils literal">previous-name ## _type</tt>, where
<tt class="docutils literal">previous-name</tt> is the
<tt class="docutils literal">argument-name</tt> in a previous
<tt class="docutils literal">specifier-group0</tt> or
<tt class="docutils literal">specifier-group1</tt>.  <em>This expression will
be invoked exactly once.</em></li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.  If <tt class="docutils literal"
>restriction</tt> uses this form, then the type of the generated name <tt
class="docutils literal">argument-name ## _type</tt> will be computed in terms
of the <strong>target type</strong>, and the generated reference
<tt class="docutils literal">argument-name</tt> (but not its corresponding
entry in <tt class="docutils literal">args</tt>) will be cast to that
type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_const_ ## __LINE__ ## operator
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_const_ ## __LINE__ ## operator
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_const_ ## __LINE__ ## operator
    boost_param_parameters_const_ ## __LINE__ ## operator;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>n</strong>&gt;::type
        = boost_param_parameters_const_ ## __LINE__ ## operator()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## operator(
        boost_param_parameters_const_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>m</strong>&gt;::type
        = boost_param_parameters_const_ ## __LINE__ ## operator()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## operator(
        boost_param_parameters_const_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_const_ ## __LINE__ ## operator&lt;Args&gt;::type
    boost_param_impl_const ## __LINE__ ## operator(Args const&amp; args) const
{
    return this-&gt;
    boost_param_dispatch_const_0boost_ ## __LINE__ ## operator(
        static_cast&lt;
            typename boost_param_result_const_ ## __LINE__ ## operator&lt;
                Args
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , args
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>0</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>0</strong>])
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of required parameter</em> ## <strong>n</strong>
            &gt;::type
        &gt;(args[ <em>keyword object of required parameter</em> ## <strong
>n</strong>])
    );
}

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>n</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_const_0boost_ ## __LINE__ ## operator(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>n</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>n</strong>
    ) const
{
    return this-&gt;
    boost_param_dispatch_const_0boost_ ## __LINE__ ## operator(
        static_cast&lt;ResultType(*)()&gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , (args, <em>keyword object of optional parameter</em> ## <strong
>n + 1</strong> =
            <em>default value of optional parameter</em> ## <strong
>n + 1</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>0</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>0</strong>
        )
      , …
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt; <em
>argument name</em> ## <strong>n</strong> ## _type&gt;(
            <em>argument name</em> ## <strong>n</strong>
        )
      , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward">forward</a>&lt;
            typename <a class="reference internal" href="#value-type"
>value_type</a>&lt;
                Args
              , <em
>keyword tag type of optional parameter</em> ## <strong>n + 1</strong>
            &gt;::type
        &gt;(<em>default value of optional parameter</em> ## <strong
>n + 1</strong>)
    );
}

<span class="vellipsis">⋮</span>

template &lt;
    typename ResultType
  , typename Args
  , typename <em>argument name</em> ## <strong>0</strong> ## _type
  , …
  , typename <em>argument name</em> ## <strong>m</strong> ## _type
&gt;
ResultType
    boost_param_dispatch_const_0boost_ ## __LINE__ ## operator(
        (ResultType(*)())
      , Args const&amp; args
      , <em>argument name</em> ## <strong>0</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>0</strong>
      , …
      , <em>argument name</em> ## <strong>m</strong> ## _type&amp;&amp; <em
>argument name</em> ## <strong>m</strong>
    ) const
</pre>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-constructor-cls-impl-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id61">7.6&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_CONSTRUCTOR(cls, impl, tag_namespace,
arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a constructor that can take in positional arguments, composed
arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">tag</tt> by default.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(y)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(z)
</pre>
<p>In the base class, implement a delegate constructor template that takes in
an <a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a>.  You must pass the identifiers with leading
underscores to <tt class="docutils literal">args</tt> in order to extract the
corresponding arguments.</p>
<pre class="first literal-block">
class char_read_base
{
    int index;
    char const* key;

 public:
    template &lt;typename Args&gt;
    explicit char_read_base(Args const&amp; args)
      : index(args[_y]), key(args[_z])
    {
    }

    BOOST_PARAMETER_FUNCTION_CALL_OPERATOR((void), tag,
        (deduced
            (required
                (y, (int))
                (z, (char const*))
            )
        )
    )
    {
        this-&gt;index = y;
        this-&gt;key = z;
    }

    <a class="reference internal"
href="#boost-parameter-const-function-call-op-result-tag-namespace-arguments"
>BOOST_PARAMETER_CONST_FUNCTION_CALL_OPERATOR</a>((char), tag,
        (deduced
            (required
                (y, (bool))
                (z, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/container/map"
>map</a>&lt;char const*,std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;))
            )
        )
    )
    {
        return y ? (
            (z.find(this-&gt;key)-&gt;second)[this-&gt;index]
        ) : this-&gt;key[this-&gt;index];
    }
};
</pre>
<p>Use the macro as a substitute for a normal constructor definition.  Note
the lack of an explicit body.  Enclose the base type in parentheses.  For each
parameter, also enclose the expected value type in parentheses.  Since the
value types are mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.</p>
<pre class="first literal-block">
struct char_reader : public char_read_base
{
    BOOST_PARAMETER_CONSTRUCTOR(char_reader, (char_read_base), tag,
        (deduced
            (required
                (y, (int))
                (z, (char const*))
            )
        )
    )
};
</pre>
<p>The following <tt class="docutils literal">char_reader</tt> constructor
calls are legal.</p>
<pre class="first literal-block">
char const* keys[] = {"foo", "bar", "baz"};
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/container/map"
>map</a>&lt;char const*,std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt; k2s;
k2s[keys[0]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("qux");
k2s[keys[1]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("wmb");
k2s[keys[2]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("zxc");

// positional arguments
char_reader r0(0, keys[0]);
BOOST_TEST_EQ('q', (r0(true, k2s)));
BOOST_TEST_EQ('f', (r0(false, k2s)));

// named arguments
char_reader r1(_z = keys[1], _y = 1);
BOOST_TEST_EQ('m', (r1(_z = k2s, _y = true)));
BOOST_TEST_EQ('a', (r1(_z = k2s, _y = false)));

// deduced arguments
char_reader r2(keys[2], 2);
BOOST_TEST_EQ('c', (r2(k2s, true)));
BOOST_TEST_EQ('z', (r2(k2s, false)));
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> and <a class="reference external"
href="../../test/preprocessor_eval_category.cpp"
>test/preprocessor_eval_category.cpp</a> test programs demonstrate proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">cls</tt> is the name of the enclosing
class.</li>
<li><tt class="docutils literal">impl</tt> is the parenthesized implementation
base class for <tt class="docutils literal">cls</tt>.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the constructor resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    )

specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.</li>
</ul>
<p>Note that <em>specifier</em> does not include <em>default-value</em>.  It
is up to the delegate constructor in <tt class="docutils literal">impl</tt> to
determine the default value of all optional arguments.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
struct boost_param_params_ ## __LINE__ ## ctor
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_ ## __LINE__ ## ctor
    constructor_parameters ## __LINE__;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<strong>cls</strong>(A0&amp;&amp; a0, …, A ## <strong
>n</strong> &amp;&amp; a ## <strong>n</strong>)
  : <strong>impl</strong>(
        constructor_parameters ## __LINE__(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    )
{
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<strong>cls</strong>(A0&amp;&amp; a0, …, A ## <strong
>m</strong>&amp;&amp; a ## <strong>m</strong>)
  : <strong>impl</strong>(
        constructor_parameters ## __LINE__(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    )
{
}
</pre>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-basic-function-result-name-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id62">7.7&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_BASIC_FUNCTION(result, name,
tag_namespace, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function that can take in positional arguments, composed
arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will be
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal function header.  Enclose the
return type <tt class="docutils literal">bool</tt> in parentheses.  For each
parameter, also enclose the expected value type in parentheses.  Since the
value types are mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  However, unlike a normal function, default values must be
specified within the function body.  Also within the function body, you must
pass the matching identifier with the leading underscore to the bracket
operator of <tt class="docutils literal">args</tt> to extract the
corresponding argument, but at least this doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
BOOST_PARAMETER_BASIC_FUNCTION((bool), evaluate, kw,
    (deduced
        (required
            (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
            (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
        )
        (optional
            (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;))
            (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;))
        )
    )
)
{
    BOOST_TEST_EQ(
        passed_by_lvalue_reference_to_const
      , U::evaluate_category&lt;0&gt;(args[_lrc])
    );
    BOOST_TEST_EQ(
        passed_by_lvalue_reference
      , U::evaluate_category&lt;1&gt;(args[_lr])
    );
    BOOST_TEST_EQ(
        passed_by_rvalue_reference_to_const
      , U::evaluate_category&lt;2&gt;(
            args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
        )
    );
    BOOST_TEST_EQ(
        passed_by_rvalue_reference
      , U::evaluate_category&lt;3&gt;(args[_rr0 | rvalue_bitset&lt;3&gt;()])
    );

    return true;
}
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
evaluate((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
evaluate(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
evaluate(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
evaluate(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
evaluate(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> test program demonstrates proper usage of this
macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated forwarding functions.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    )

specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.</li>
</ul>
<p>Note that <em>specifier</em> does not include <em>default-value</em>.  It
is up to the function body to determine the default value of all optional
arguments.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_ ## __LINE__ ## <strong>name</strong>
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_ ## __LINE__ ## <strong>name</strong>
    boost_param_parameters_ ## __LINE__ ## <strong>name</strong>;

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## <strong
>name</strong>&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## <strong>name</strong>(Args const&amp;);

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>::match&lt;
            A0, …, A ## <strong>n</strong>
        &gt;::type = boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>()
    )
{
    return boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>::match&lt;
            A0, …, A ## <strong>m</strong>
        &gt;::type = boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>()
    )
{
    return boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## <strong
>name</strong>&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## <strong
>name</strong>(Args const&amp; args)
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-basic-member-function-result-name-tag-ns-arguments">
<h2><a class="toc-backref" href="#id63">7.8&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_BASIC_MEMBER_FUNCTION(result, name,
tag_namespace, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a member function that can take in positional arguments, composed
arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will be
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal <tt class="docutils literal"
>static</tt> member function header.  Enclose the return type <tt
class="docutils literal">bool</tt> in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  However, unlike a normal function, default values must be
specified within the function body.  Also within the function body, you must
pass the matching identifier with the leading underscore to the bracket
operator of <tt class="docutils literal">args</tt> to extract the
corresponding argument, but at least this doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
struct B
{
    BOOST_PARAMETER_BASIC_MEMBER_FUNCTION((bool), static evaluate, kw,
        (deduced
            (required
                (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
                (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
            )
            (optional
                (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;))
                (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;))
            )
        )
    )
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(args[_lrc])
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(args[_lr])
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(
                args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
            )
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(
                args[_rr0 | rvalue_bitset&lt;3&gt;()]
            )
        );

        return true;
    }
};
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
B::evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
B::evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
B::evaluate((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
B::evaluate(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
B::evaluate(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
B::evaluate(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
B::evaluate(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> test program demonstrates proper usage of this
macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated forwarding functions.  <tt
class="docutils literal">name</tt> may be qualified by the <tt
class="docutils literal">static</tt> keyword to declare the member function
and its helpers as not associated with any object of the enclosing type.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    )

specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.</li>
</ul>
<p>Note that <em>specifier</em> does not include <em>default-value</em>.  It
is up to the function body to determine the default value of all optional
arguments.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_ ## __LINE__ ## <strong>name</strong>
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_ ## __LINE__ ## <strong>name</strong>
    boost_param_parameters_ ## __LINE__ ## <strong>name</strong>;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>::match&lt;
            A0, …, A ## <strong>n</strong>
        &gt;::type = boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>::match&lt;
            A0, …, A ## <strong>m</strong>
        &gt;::type = boost_param_parameters_ ## __LINE__ ## <strong
>name</strong>()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## <strong>name</strong>(
        boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## <strong
>name</strong>&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## <strong
>name</strong>(Args const&amp; args)
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-basic-c-mem-function-result-name-tag-ns-arguments">
<h2><a class="toc-backref" href="#id64">7.9&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_BASIC_CONST_MEMBER_FUNCTION(result,
name, tag_namespace, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a member function that can take in positional arguments, composed
arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will b
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal <tt class="docutils literal"
>const</tt> member function header.  Enclose the return type <tt
class="docutils literal">bool</tt> in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  However, unlike a normal function, default values must be
specified within the function body.  Also within the function body, you must
pass the matching identifier with the leading underscore to the bracket
operator of <tt class="docutils literal">args</tt> to extract the
corresponding argument, but at least this doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
struct B
{
    B()
    {
    }

    BOOST_PARAMETER_BASIC_CONST_MEMBER_FUNCTION((bool), evaluate, kw,
        (deduced
            (required
                (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
                (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
            )
            (optional
                (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;))
                (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;))
            )
        )
    )
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(args[_lrc])
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(args[_lr])
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(
                args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
            )
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(
                args[_rr0 | rvalue_bitset&lt;3&gt;()]
            )
        );

        return true;
    }
};
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
B const b = B();
b.evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
b.evaluate(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
b.evaluate((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
b.evaluate(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
b.evaluate(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
b.evaluate(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
b.evaluate(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> test program demonstrates proper usage of this
macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated forwarding functions.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    )

specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.</li>
</ul>
<p>Note that <em>specifier</em> does not include <em>default-value</em>.  It
is up to the function body to determine the default value of all optional
arguments.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_const_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_const_ ## __LINE__ ## <strong>name</strong>
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_const_ ## __LINE__ ## <strong>name</strong>
    boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## <strong
>name</strong>::match&lt;
            A0, …, A ## <strong>n</strong>
        &gt;::type = boost_param_parameters_const_ ## __LINE__ ## <strong
>name</strong>()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## <strong
>name</strong>(
        boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    <strong>name</strong>(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## <strong
>name</strong>::match&lt;
            A0, …, A ## <strong>m</strong>
        &gt;::type = boost_param_parameters_const_ ## __LINE__ ## <strong
>name</strong>()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## <strong
>name</strong>(
        boost_param_parameters_const_ ## __LINE__ ## <strong>name</strong>()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_const_ ## __LINE__ ## <strong
>name</strong>&lt;Args&gt;::type
    boost_param_impl_const ## __LINE__ ## <strong
>name</strong>(Args const&amp; args) const
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-basic-function-call-op-result-tag-namespace-arguments">
<h2><a class="toc-backref" href="#id65">7.10&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_BASIC_FUNCTION_CALL_OPERATOR(result,
tag_ns, arguments)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function call operator that can take in positional arguments,
composed arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">tag</tt> by default.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(y)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(z)
</pre>
<p>Use the macro as a substitute for a normal function call operator
header.  Enclose the return type in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  This is especially useful
when implementing multiple Boost.Parameter-enabled function call operator
overloads.</p>
<pre class="first literal-block">
class char_reader
{
    int index;
    char const* key;

 public:
    explicit char_reader(char const* k) : index(0), key(k)
    {
    }

    BOOST_PARAMETER_BASIC_FUNCTION_CALL_OPERATOR((void), tag,
        (deduced
            (required
                (y, (int))
                (z, (char const*))
            )
        )
    )
    {
        this-&gt;index = args[_y];
        this-&gt;key = args[_z];
    }

    <a class="reference internal"
href="#boost-parameter-basic-const-function-call-op-result-tag-ns-args"
>BOOST_PARAMETER_BASIC_CONST_FUNCTION_CALL_OPERATOR</a>((char), tag,
        (deduced
            (required
                (y, (bool))
                (z, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/container/map"
>map</a>&lt;char const*,std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string">string</a>&gt;))
            )
        )
    )
    {
        return args[_y] ? (
            (args[_z].find(this-&gt;key)-&gt;second)[this-&gt;index]
        ) : this-&gt;key[this-&gt;index];
    }
};
</pre>
<p>As with regular argument-dependent lookup, the value types of the arguments
passed in determine which function call operator overload gets invoked.</p>
<pre class="first literal-block">
char const* keys[] = {"foo", "bar", "baz"};
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/container/map"
>map</a>&lt;char const*,std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt; k2s;
k2s[keys[0]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("qux");
k2s[keys[1]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("wmb");
k2s[keys[2]] = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/string/basic_string"
>string</a>&gt;("zxc");
char_reader r(keys[0]);

// positional arguments
BOOST_TEST_EQ('q', (r(true, k2s)));
BOOST_TEST_EQ('f', (r(false, k2s)));

// named arguments
r(_z = keys[1], _y = 1);
BOOST_TEST_EQ('m', (r(_z = k2s, _y = true)));
BOOST_TEST_EQ('a', (r(_z = k2s, _y = false)));

// deduced arguments
r(keys[2], 2);
BOOST_TEST_EQ('c', (r(k2s, true)));
BOOST_TEST_EQ('z', (r(k2s, false)));
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> test program demonstrates proper usage of this
macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function call operator.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function call operator resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    )

specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.</li>
</ul>
<p>Note that <em>specifier</em> does not include <em>default-value</em>.  It
is up to the function body to determine the default value of all optional
arguments.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_ ## __LINE__ ## operator
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_ ## __LINE__ ## operator
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_ ## __LINE__ ## operator
    boost_param_parameters_ ## __LINE__ ## operator;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>n</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## operator()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## operator(
        boost_param_parameters_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>m</strong>&gt;::type
        = boost_param_parameters_ ## __LINE__ ## operator()
    )
{
    return this-&gt;boost_param_impl ## __LINE__ ## operator(
        boost_param_parameters_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_ ## __LINE__ ## operator&lt;Args&gt;::type
    boost_param_impl ## __LINE__ ## operator(Args const&amp; args)
</pre>
</dd>
</dl>
</div>
<div class="section"
id="boost-parameter-basic-const-function-call-op-result-tag-ns-args">
<h2><a class="toc-backref" href="#id66">7.11&nbsp;&nbsp;&nbsp;<tt
class="docutils literal"
>BOOST_PARAMETER_BASIC_CONST_FUNCTION_CALL_OPERATOR(result, tag_ns,
args)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor.hpp"
>boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function call operator that can take in positional arguments,
composed arguments, named arguments, and deduced arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Define the named parameters that will comprise the argument specification
that this macro will use.  Ensure that all their tag types are in the same
namespace, which is <tt class="docutils literal">kw</tt> in this case.  The
identifiers with leading underscores can be passed to the bracket operator of
<tt class="docutils literal">args</tt> to extract the same argument to which
the corresponding named parameter (without underscores) is bound, as will be
shown later.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw) consume(rr))
</pre>
<p>Use the macro as a substitute for a normal <tt class="docutils literal"
>const</tt> function call operator header.  Enclose the return type <tt
class="docutils literal">bool</tt> in parentheses.  For each parameter, also
enclose the expected value type in parentheses.  Since the value types are
mutually exclusive, you can wrap the parameters in a <tt
class="docutils literal">(deduced …)</tt> clause.  Otherwise, just as with a
normal function, the order in which you specify the parameters determines
their position.  However, unlike a normal function, default values must be
specified within the function body.  Also within the function body, you must
pass the matching identifier with the leading underscore to the bracket
operator of <tt class="docutils literal">args</tt> to extract the
corresponding argument, but at least this doesn't require <tt
class="docutils literal">std::forward</tt> to preserve value categories.</p>
<pre class="first literal-block">
struct B
{
    B()
    {
    }

    BOOST_PARAMETER_BASIC_CONST_FUNCTION_CALL_OPERATOR((bool), kw,
        (deduced
            (required
                (lrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;1&gt;))
                (lr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;2&gt;))
            )
            (optional
                (rrc, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;3&gt;))
                (rr, (std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;4&gt;))
            )
        )
    )
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(args[_lrc])
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(args[_lr])
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(
                args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
            )
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(
                args[_rr0 | rvalue_bitset&lt;3&gt;()]
            )
        );

        return true;
    }
};
</pre>
<p>The following function calls are legal.</p>
<pre class="first literal-block">
B const b = B();
b(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
  , rvalue_bitset&lt;3&gt;()
);
b(  // positional arguments
    lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
);
b((  // composed arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
));
b(  // named arguments
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
b(  // named arguments
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>Because the parameters were wrapped in a <tt class="docutils literal"
>(deduced …)</tt> clause, the following function calls are also legal.</p>
<pre class="first literal-block">
b(  // deduced arguments
    rvalue_bitset&lt;3&gt;()
  , lvalue_const_bitset&lt;0&gt;()
  , lvalue_bitset&lt;1&gt;()
  , rvalue_const_bitset&lt;2&gt;()
);
b(  // deduced arguments
    lvalue_bitset&lt;1&gt;()
  , lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external" href="../../test/preprocessor.cpp"
>test/preprocessor.cpp</a> test program demonstrates proper usage of this
macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function call operator.</li>
<li><tt class="docutils literal">tag_namespace</tt> is the namespace in which
the keywords used by the function call operator resides.</li>
<li><tt class="docutils literal">arguments</tt> is a list of <em>argument
specifiers</em>, as defined below.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<pre class="first literal-block">
argument-specifiers ::= <em>specifier-group0</em> {<em>specifier-group0</em>}

specifier-group0 ::= <em>specifier-group1</em> |
    (
        '<strong>(</strong>' '<strong>deduced</strong>'
            <em>specifier-group1</em> {<em>specifier-group1</em>}
        '<strong>)</strong>'
    )

specifier-group1 ::=
    (
        '<strong>(</strong>' '<strong>optional</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    ) | (
        '<strong>(</strong>' '<strong>required</strong>'
            <em>specifier</em> {<em>specifier</em>}
        '<strong>)</strong>'
    )

specifier ::=
    '<strong>(</strong>' <em>argument-name</em> '<strong>,</strong>' <em
>restriction</em> ')'

restriction ::=
    ( '<strong>*</strong>' '<strong>(</strong>' <em>mfc</em> '<strong
>)</strong>' ) |
    ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |
    '<strong>*</strong>'
</pre>
<ul class="last simple">
<li><tt class="docutils literal">argument-name</tt> is any valid C++
identifier.</li>
<li><tt class="docutils literal">mfc</tt> is an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is a
<a class="reference external"
href="../../../mpl/doc/refmanual/integral-constant.html">Boolean Integral
Concept</a>; however, user code <em>cannot</em> compute
<tt class="docutils literal">mfc</tt> in terms of
<tt class="docutils literal">previous-name ## _type</tt>.</li>
<li><tt class="docutils literal">type-name</tt> is either the name of a
<strong>target type</strong> or an <a class="reference external"
href="../../../mpl/doc/refmanual/metafunction-class.html">MPL Binary
Metafunction Class</a> whose first argument will be the type of the
corresponding <tt class="docutils literal">argument-name</tt>, whose second
argument will be the entire <a class="reference internal" href="#argumentpack"
><span class="concept">ArgumentPack</span></a>, and whose return type is the
<strong>target type</strong>.</li>
</ul>
<p>Note that <em>specifier</em> does not include <em>default-value</em>.  It
is up to the function body to determine the default value of all optional
arguments.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<p class="first"><strong>Where</strong>:</p>
<ul class="simple">
<li><tt class="docutils literal">n</tt> denotes the <em>minimum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
<li><tt class="docutils literal">m</tt> denotes the <em>maximum</em> arity, as
determined from <tt class="docutils literal">arguments</tt>.</li>
</ul>
<pre class="last literal-block">
template &lt;typename T&gt;
struct boost_param_result_const_ ## __LINE__ ## operator
{
    typedef <strong>result</strong> type;
};

struct boost_param_params_const_ ## __LINE__ ## operator
  : <a class="reference internal" href="#parameters">parameters</a>&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{
};

typedef boost_param_params_const_ ## __LINE__ ## operator
    boost_param_parameters_const_ ## __LINE__ ## operator;

template &lt;typename A0, …, typename A ## <strong>n</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>n</strong> &amp;&amp; a ## <strong
>n</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>n</strong>&gt;::type
        = boost_param_parameters_const_ ## __LINE__ ## operator()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## operator(
        boost_param_parameters_const_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>n</strong>&gt;(a ## <strong>n</strong>)
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A0, …, typename A ## <strong>m</strong>&gt;
<em>result type</em>
    operator()(
        A0&amp;&amp; a0, …, A ## <strong>m</strong> &amp;&amp; a ## <strong
>m</strong>
      , typename boost_param_parameters_const_ ## __LINE__ ## operator
        ::match&lt;A0, …, A ## <strong>m</strong>&gt;::type
        = boost_param_parameters_const_ ## __LINE__ ## operator()
    ) const
{
    return this-&gt;boost_param_impl_const ## __LINE__ ## operator(
        boost_param_parameters_const_ ## __LINE__ ## operator()(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A0&gt;(a0)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>m</strong>&gt;(a ## <strong>m</strong>)
        )
    );
}

template &lt;typename Args&gt;
typename boost_param_result_const_ ## __LINE__ ## operator&lt;Args&gt;::type
    boost_param_impl_const ## __LINE__ ## operator(Args const&amp; args) const
</pre>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-no-spec-function-result-name">
<h2><a class="toc-backref" href="#id67">7.12&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_FUNCTION(result,
name)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor_no_spec.hpp"
>boost/parameter/preprocessor_no_spec.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function that can take in named arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Named parameters are required when invoking the function; however, none of
their tags need to be in the same namespace.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw0) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw1) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw2) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw3) consume(rr))
</pre>
<p>Use the macro as a substitute for a variadic function header.  Enclose the
return type <tt class="docutils literal">bool</tt> in parentheses.</p>
<pre class="first literal-block">
BOOST_PARAMETER_NO_SPEC_FUNCTION((bool), evaluate)
{
    BOOST_TEST_EQ(
        passed_by_lvalue_reference_to_const
      , U::evaluate_category&lt;0&gt;(args[_lrc])
    );
    BOOST_TEST_EQ(
        passed_by_lvalue_reference
      , U::evaluate_category&lt;1&gt;(args[_lr])
    );
    BOOST_TEST_EQ(
        passed_by_rvalue_reference_to_const
      , U::evaluate_category&lt;2&gt;(
            args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
        )
    );
    BOOST_TEST_EQ(
        passed_by_rvalue_reference
      , U::evaluate_category&lt;3&gt;(args[_rr0 | rvalue_bitset&lt;3&gt;()])
    );

    return true;
}
</pre>
<p>To invoke the function, bind all its arguments to named parameters.</p>
<pre class="first literal-block">
evaluate(
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
evaluate(
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external"
href="../../test/preprocessor_eval_cat_no_spec.cpp"
>test/preprocessor_eval_cat_no_spec.cpp</a> test program demonstrates proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated implementation function.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">None.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<pre class="last literal-block">
template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
struct boost_param_no_spec_result_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

template &lt;typename ResultType, typename Args&gt;
ResultType
    boost_param_no_spec_impl ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
    );

template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
inline typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">lazy_enable_if</a>&lt;
    <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0,TaggedArgs...&gt;
  , boost_param_no_spec_result_ ## __LINE__ ## <strong>name</strong>&lt;
        TaggedArg0
      , TaggedArgs...
    &gt;
&gt;::type
    <strong>name</strong
>(TaggedArg0 const&amp; arg0, TaggedArgs const&amp;... args)
{
    return boost_param_no_spec_impl ## __LINE__ ## <strong>name</strong>(
        static_cast&lt;
            typename
            boost_param_no_spec_result_ ## __LINE__ ## <strong
>name</strong>&lt;
                TaggedArg0
              , TaggedArgs...
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , <a class="reference internal" href="compose"
>compose</a>(arg0, args...)
    );
}

template &lt;typename ResultType, typename Args&gt;
ResultType
    boost_param_no_spec_impl ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
    )
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-no-spec-member-function-result-name">
<h2><a class="toc-backref" href="#id68">7.13&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_MEMBER_FUNCTION(result,
name)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor_no_spec.hpp"
>boost/parameter/preprocessor_no_spec.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a member function that can take in named arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>When designing a front-end class template whose back-end is configurable
via parameterized inheritance, it can be useful to omit argument specifiers
from a named-parameter member function so that the delegate member functions
of the back-end classes can enforce their own specifications.</p>
<pre class="first literal-block">
template &lt;typename B&gt;
struct frontend : B
{
    frontend() : B()
    {
    }

    BOOST_PARAMETER_NO_SPEC_MEMBER_FUNCTION((void), initialize)
    {
        this-&gt;initialize_impl(args);
    }
};
</pre>
<p>Named parameters are required when invoking the member function; however,
none of their tags need to be in the same namespace.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a0)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a1)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a2)
</pre>
<p>For this example, each of the back-end class templates requires its own
parameter to be present in the argument pack.  In practice, such parameters
should be optional, with default values.</p>
<pre class="first literal-block">
template &lt;typename T&gt;
class backend0
{
    T a0;

 public:
    backend0() : a0()
    {
    }

    T const&amp; get_a0() const
    {
        return this-&gt;a0;
    }

 protected:
    template &lt;typename ArgPack&gt;
    void initialize_impl(ArgPack const&amp; args)
    {
        this-&gt;a0 = args[_a0];
    }
};

template &lt;typename B, typename T&gt;
class backend1 : public B
{
    T a1;

 public:
    backend1() : B(), a1()
    {
    }

    T const&amp; get_a1() const
    {
        return this-&gt;a1;
    }

 protected:
    template &lt;typename ArgPack&gt;
    void initialize_impl(ArgPack const&amp; args)
    {
        B::initialize_impl(args);
        this-&gt;a1 = args[_a1];
    }
};

template &lt;typename B, typename T&gt;
class backend2 : public B
{
    T a2;

 public:
    backend2() : B(), a2()
    {
    }

    T const&amp; get_a2() const
    {
        return this-&gt;a2;
    }

 protected:
    template &lt;typename ArgPack&gt;
    void initialize_impl(ArgPack const&amp; args)
    {
        B::initialize_impl(args);
        this-&gt;a2 = args[_a2];
    }
};
</pre>
<p>This example shows that while <tt class="docutils literal">backend0</tt>
must always be the root base class template and that <tt
class="docutils literal">frontend</tt> must always be the most derived class
template, the other back-ends can be chained together in different orders.</p>
<pre class="first literal-block">
char const* p = "foo";
frontend&lt;
    backend2&lt;backend1&lt;backend0&lt;char const*&gt;, char&gt;, int&gt;
&gt; composed_obj0;
frontend&lt;
    backend1&lt;backend2&lt;backend0&lt;char const*&gt;, int&gt;, char&gt;
&gt; composed_obj1;
composed_obj0.initialize(_a2 = 4, _a1 = ' ', _a0 = p);
composed_obj1.initialize(_a0 = p, _a1 = ' ', _a2 = 4);
BOOST_TEST_EQ(composed_obj0.get_a0(), composed_obj1.get_a0());
BOOST_TEST_EQ(composed_obj0.get_a1(), composed_obj1.get_a1());
BOOST_TEST_EQ(composed_obj0.get_a2(), composed_obj1.get_a2());
</pre>
<p>The <a class="reference external"
href="../../test/parameterized_inheritance.cpp"
>test/parameterized_inheritance.cpp</a> and <a class="reference external"
href="../../test/preprocessor_eval_cat_no_spec.cpp"
>test/preprocessor_eval_cat_no_spec.cpp</a> test programs demonstrate proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated implementation function.  <tt
class="docutils literal">name</tt> may be qualified by the <tt
class="docutils literal">static</tt> keyword to declare the member function
and its helpers as not associated with any object of the enclosing type.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">None.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<pre class="last literal-block">
template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
struct boost_param_no_spec_result_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
inline typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">lazy_enable_if</a>&lt;
    <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0,TaggedArgs...&gt;
  , boost_param_no_spec_result_ ## __LINE__ ## <strong>name</strong>&lt;
        TaggedArg0
      , TaggedArgs...
    &gt;
&gt;::type
    <strong>name</strong
>(TaggedArg0 const&amp; arg0, TaggedArgs const&amp;... args)
{
    return this-&gt;boost_param_no_spec_impl ## __LINE__ ## <strong
>name</strong>(
        static_cast&lt;
            typename
            boost_param_no_spec_result_ ## __LINE__ ## <strong
>name</strong>&lt;
                TaggedArg0
              , TaggedArgs...
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , <a class="reference internal" href="compose"
>compose</a>(arg0, args...)
    );
}

template &lt;typename ResultType, typename Args&gt;
ResultType
    boost_param_no_spec_impl ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
    )
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-no-spec-c-mem-function-result-name">
<h2><a class="toc-backref" href="#id69">7.14&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_CONST_MEMBER_FUNCTION(result,
name)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor_no_spec.hpp"
>boost/parameter/preprocessor_no_spec.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a member function that can take in named arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Named parameters are required when invoking the member function; however,
none of their tags need to be in the same namespace.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw0) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw1) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw2) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw3) consume(rr))
</pre>
<p>Use the macro as a substitute for a variadic function header.  Enclose the
return type <tt class="docutils literal">bool</tt> in parentheses.  The macro
will qualify the function with the <tt class="docutils literal">const</tt>
keyword.</p>
<pre class="first literal-block">
struct D
{
    D()
    {
    }

    BOOST_PARAMETER_NO_SPEC_CONST_MEMBER_FUNCTION((bool), evaluate_m)
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(args[_lrc])
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(args[_lr])
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(
                args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
            )
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(
                args[_rr0 | rvalue_bitset&lt;3&gt;()]
            )
        );

        return true;
    }
};
</pre>
<p>To invoke the member function, bind all its arguments to named
parameters.</p>
<pre class="first literal-block">
D const d = D();
d.evaluate_m(
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
d.evaluate_m(
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external"
href="../../test/preprocessor_eval_cat_no_spec.cpp"
>test/preprocessor_eval_cat_no_spec.cpp</a> test program demonstrates proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function.</li>
<li><tt class="docutils literal">name</tt> is the base name of the function;
it determines the name of the generated implementation function.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">None.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<pre class="last literal-block">
template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
struct boost_param_no_spec_result_const_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;
};

template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
inline typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html"><tt
class="docutils literal">lazy_enable_if</tt></a>&lt;
    <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0,TaggedArgs...&gt;
  , boost_param_no_spec_result_const_ ## __LINE__ ## <strong>name</strong>&lt;
        TaggedArg0
      , TaggedArgs...
    &gt;
&gt;::type
    <strong>name</strong
>(TaggedArg0 const&amp; arg0, TaggedArgs const&amp;... args) const
{
    return this-&gt;boost_param_no_spec_impl_const ## __LINE__ ## <strong
>name</strong>(
        static_cast&lt;
            typename
            boost_param_no_spec_result_const_ ## __LINE__ ## <strong
>name</strong>&lt;
                TaggedArg0
              , TaggedArgs...
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , <a class="reference internal" href="compose"
>compose</a>(arg0, args...)
    );
}

template &lt;typename ResultType, typename Args&gt;
ResultType
    boost_param_no_spec_impl_const ## __LINE__ ## <strong>name</strong>(
        (ResultType(*)())
      , Args const&amp; args
    ) const
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-no-spec-function-call-op-result">
<h2><a class="toc-backref" href="#id70">7.15&nbsp;&nbsp;&nbsp;<tt
class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_FUNCTION_CALL_OPERATOR(result)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor_no_spec.hpp"
>boost/parameter/preprocessor_no_spec.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function call operator that can take in named arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>When designing a front-end class template whose back-end is configurable
via parameterized inheritance, it can be useful to omit argument specifiers
from a named-parameter function call operator so that the delegate member
functions of the back-end classes can enforce their own specifications.</p>
<pre class="first literal-block">
template &lt;typename B&gt;
struct frontend : B
{
    frontend() : B()
    {
    }

    BOOST_PARAMETER_NO_SPEC_FUNCTION_CALL_OPERATOR((void))
    {
        this-&gt;initialize_impl(args);
    }
};
</pre>
<p>Named parameters are required when invoking the function call operator;
however, none of their tags need to be in the same namespace.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a0)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a1)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a2)
</pre>
<p>For this example, each of the back-end class templates requires its own
parameter to be present in the argument pack.  In practice, such parameters
should be optional, with default values.</p>
<pre class="first literal-block">
template &lt;typename T&gt;
class backend0
{
    T a0;

 public:
    backend0() : a0()
    {
    }

    T const&amp; get_a0() const
    {
        return this-&gt;a0;
    }

 protected:
    template &lt;typename ArgPack&gt;
    void initialize_impl(ArgPack const&amp; args)
    {
        this-&gt;a0 = args[_a0];
    }
};

template &lt;typename B, typename T&gt;
class backend1 : public B
{
    T a1;

 public:
    backend1() : B(), a1()
    {
    }

    T const&amp; get_a1() const
    {
        return this-&gt;a1;
    }

 protected:
    template &lt;typename ArgPack&gt;
    void initialize_impl(ArgPack const&amp; args)
    {
        B::initialize_impl(args);
        this-&gt;a1 = args[_a1];
    }
};

template &lt;typename B, typename T&gt;
class backend2 : public B
{
    T a2;

 public:
    backend2() : B(), a2()
    {
    }

    T const&amp; get_a2() const
    {
        return this-&gt;a2;
    }

 protected:
    template &lt;typename ArgPack&gt;
    void initialize_impl(ArgPack const&amp; args)
    {
        B::initialize_impl(args);
        this-&gt;a2 = args[_a2];
    }
};
</pre>
<p>This example shows that while <tt class="docutils literal">backend0</tt>
must always be the root base class template and that <tt
class="docutils literal">frontend</tt> must always be the most derived class
template, the other back-ends can be chained together in different orders.</p>
<pre class="first literal-block">
char const* p = "foo";
frontend&lt;
    backend2&lt;backend1&lt;backend0&lt;char const*&gt;, char&gt;, int&gt;
&gt; composed_obj0;
frontend&lt;
    backend1&lt;backend2&lt;backend0&lt;char const*&gt;, int&gt;, char&gt;
&gt; composed_obj1;
composed_obj0(_a2 = 4, _a1 = ' ', _a0 = p);
composed_obj1(_a0 = p, _a1 = ' ', _a2 = 4);
BOOST_TEST_EQ(composed_obj0.get_a0(), composed_obj1.get_a0());
BOOST_TEST_EQ(composed_obj0.get_a1(), composed_obj1.get_a1());
BOOST_TEST_EQ(composed_obj0.get_a2(), composed_obj1.get_a2());
</pre>
<p>The <a class="reference external"
href="../../test/parameterized_inheritance.cpp"
>test/parameterized_inheritance.cpp</a> and <a class="reference external"
href="../../test/preprocessor_eval_cat_no_spec.cpp"
>test/preprocessor_eval_cat_no_spec.cpp</a> test programs demonstrate proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function call operator.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">None.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<pre class="last literal-block">
template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
struct boost_param_no_spec_result_ ## __LINE__ ## operator
{
    typedef <strong>result</strong> type;
};

template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
inline typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">lazy_enable_if</a>&lt;
    <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0,TaggedArgs...&gt;
  , boost_param_no_spec_result_ ## __LINE__ ## operator&lt;
        TaggedArg0
      , TaggedArgs...
    &gt;
&gt;::type
    operator()(TaggedArg0 const&amp; arg0, TaggedArgs const&amp;... args)
{
    return this-&gt;boost_param_no_spec_impl ## __LINE__ ## operator(
        static_cast&lt;
            typename
            boost_param_no_spec_result_ ## __LINE__ ## operator&lt;
                TaggedArg0
              , TaggedArgs...
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , <a class="reference internal" href="compose"
>compose</a>(arg0, args...)
    );
}

template &lt;typename ResultType, typename Args&gt;
ResultType
    boost_param_no_spec_impl ## __LINE__ ## operator(
        (ResultType(*)())
      , Args const&amp; args
    )
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-no-spec-const-func-call-op-result">
<h2><a class="toc-backref" href="#id71">7.16&nbsp;&nbsp;&nbsp;<tt
class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_CONST_FUNCTION_CALL_OPERATOR(result)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor_no_spec.hpp"
>boost/parameter/preprocessor_no_spec.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a function call operator that can take in named arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following function templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Named parameters are required when invoking the function call operator;
however, none of their tags need to be in the same namespace.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw0) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw1) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw2) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw3) consume(rr))
</pre>
<p>Use the macro as a substitute for a variadic function call operator
header.  Enclose the return type <tt class="docutils literal">bool</tt> in
parentheses.  The macro will qualify the function with the <tt
class="docutils literal">const</tt> keyword.</p>
<pre class="first literal-block">
struct D
{
    D()
    {
    }

    BOOST_PARAMETER_NO_SPEC_CONST_FUNCTION_CALL_OPERATOR((bool))
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(args[_lrc])
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(args[_lr])
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(
                args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
            )
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(
                args[_rr0 | rvalue_bitset&lt;3&gt;()]
            )
        );

        return true;
    }
};
</pre>
<p>To invoke the function call operator, bind all its arguments to named
parameters.</p>
<pre class="first literal-block">
D const d = D();
d(
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
d(
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external"
href="../../test/preprocessor_eval_cat_no_spec.cpp"
>test/preprocessor_eval_cat_no_spec.cpp</a> test program demonstrates proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">result</tt> is the parenthesized return type
of the function call operator.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">None.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<pre class="last literal-block">
template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
struct boost_param_no_spec_result_const_ ## __LINE__ ## operator
{
    typedef <strong>result</strong> type;
};

template &lt;typename TaggedArg0, typename ...TaggedArgs&gt;
inline typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">lazy_enable_if</a>&lt;
    <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0,TaggedArgs...&gt;
  , boost_param_no_spec_result_const_ ## __LINE__ ## operator&lt;
        TaggedArg0
      , TaggedArgs...
    &gt;
&gt;::type
    operator()(
        TaggedArg0 const&amp; arg0
      , TaggedArgs const&amp;... args
    ) const
{
    return this-&gt;boost_param_no_spec_impl_const ## __LINE__ ## operator(
        static_cast&lt;
            typename
            boost_param_no_spec_result_const_ ## __LINE__ ## operator&lt;
                TaggedArg0
              , TaggedArgs...
            &gt;::type(*)()
        &gt;(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/language/nullptr">nullptr</a>)
      , <a class="reference internal" href="compose"
>compose</a>(arg0, args...)
    );
}

template &lt;typename ResultType, typename Args&gt;
ResultType
    boost_param_no_spec_impl_const ## __LINE__ ## operator(
        (ResultType(*)())
      , Args const&amp; args
    ) const
</pre>
<p>Only the <a class="reference internal" href="#argumentpack"><span
class="concept">ArgumentPack</span></a> type <tt class="docutils literal"
>Args</tt> and its object instance <tt class="docutils literal">args</tt> are
available for use within the function body.</p>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-no-spec-constructor-cls-impl">
<h2><a class="toc-backref" href="#id72">7.17&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_CONSTRUCTOR(cls,
impl)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor_no_spec.hpp"
>boost/parameter/preprocessor_no_spec.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a constructor that can take in named arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>When designing a front-end class template whose back-end is configurable
via parameterized inheritance, it can be useful to omit argument specifiers
from a named-parameter constructor so that the delegate constructors of the
back-end classes can enforce their own specifications.</p>
<pre class="first literal-block">
template &lt;typename B&gt;
struct frontend : B
{
    BOOST_PARAMETER_NO_SPEC_CONSTRUCTOR(frontend, (B))
};
</pre>
<p>Named parameters are required when invoking the constructor; however, none
of their tags need to be in the same namespace.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a0)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a1)
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>(a2)
</pre>
<p>For this example, each of the back-end class templates requires its own
parameter to be present in the argument pack.  In practice, such parameters
should be optional, with default values.</p>
<pre class="first literal-block">
struct _enabler
{
};

template &lt;typename T&gt;
class backend0
{
    T a0;

 public:
    template &lt;typename ArgPack&gt;
    explicit backend0(
        ArgPack const&amp; args
      , typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
            <a class="reference internal" href="#is-argument-pack"
>is_argument_pack</a>&lt;ArgPack&gt;
          , _enabler
        &gt;::type = _enabler()
    ) : a0(args[_a0])
    {
    }

    T const&amp; get_a0() const
    {
        return this-&gt;a0;
    }
};

template &lt;typename B, typename T&gt;
class backend1 : public B
{
    T a1;

 public:
    template &lt;typename ArgPack&gt;
    explicit backend1(
        ArgPack const&amp; args
      , typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
            <a class="reference internal" href="#is-argument-pack"
>is_argument_pack</a>&lt;ArgPack&gt;
          , _enabler
        &gt;::type = _enabler()
    ) : B(args), a1(args[_a1])
    {
    }

    T const&amp; get_a1() const
    {
        return this-&gt;a1;
    }
};

template &lt;typename B, typename T&gt;
class backend2 : public B
{
    T a2;

 public:
    template &lt;typename ArgPack&gt;
    explicit backend2(
        ArgPack const&amp; args
      , typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
            <a class="reference internal" href="#is-argument-pack"
>is_argument_pack</a>&lt;ArgPack&gt;
          , _enabler
        &gt;::type = _enabler()
    ) : B(args), a2(args[_a2])
    {
    }

    T const&amp; get_a2() const
    {
        return this-&gt;a2;
    }
};
</pre>
<p>This example shows that while <tt class="docutils literal">backend0</tt>
must always be the root base class template and that <tt
class="docutils literal">frontend</tt> must always be the most derived class
template, the other back-ends can be chained together in different orders.</p>
<pre class="first literal-block">
char const* p = "foo";
frontend&lt;
    backend2&lt;backend1&lt;backend0&lt;char const*&gt;, char&gt;, int&gt;
&gt; composed_obj0(_a2 = 4, _a1 = ' ', _a0 = p);
frontend&lt;
    backend1&lt;backend2&lt;backend0&lt;char const*&gt;, int&gt;, char&gt;
&gt; composed_obj1(_a0 = p, _a1 = ' ', _a2 = 4);
BOOST_TEST_EQ(composed_obj0.get_a0(), composed_obj1.get_a0());
BOOST_TEST_EQ(composed_obj0.get_a1(), composed_obj1.get_a1());
BOOST_TEST_EQ(composed_obj0.get_a2(), composed_obj1.get_a2());
</pre>
<p>The <a class="reference external"
href="../../test/parameterized_inheritance.cpp"
>test/parameterized_inheritance.cpp</a> and <a class="reference external"
href="../../test/preprocessor_eval_cat_no_spec.cpp"
>test/preprocessor_eval_cat_no_spec.cpp</a> test programs demonstrate proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">cls</tt> is the name of the enclosing
class.</li>
<li><tt class="docutils literal">impl</tt> is the parenthesized implementation
base class for <tt class="docutils literal">cls</tt>.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">None.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<pre class="last literal-block">
template &lt;
    template <
        typename TaggedArg0
      , typename ...TaggedArgs
      , typename = typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
            <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0,TaggedArgs...&gt;
        &gt;::type
&gt;
inline explicit <strong>cls</strong>(
    TaggedArg0 const&amp; arg0
  , TaggedArgs const&amp;... args
) : <strong>impl</strong>(<a class="reference internal" href="compose"
>compose</a>(arg0, args...))
{
}
</pre>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-no-spec-no-base-ctor-cls-func">
<h2><a class="toc-backref" href="#id73">7.18&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_NO_BASE_CONSTRUCTOR(cls,
func)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/preprocessor_no_spec.hpp"
>boost/parameter/preprocessor_no_spec.hpp</a></td>
</tr>
</tbody>
</table>
<p>Generates a constructor that can take in named arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name" colspan="2">Example usage:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<p>The return type of each of the following functon templates falls under a
different value category.</p>
<pre class="first literal-block">
template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; rvalue_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const rvalue_const_bitset()
{
    return std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp; lvalue_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; lset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return lset;
}

template &lt;std::size_t N&gt;
std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp; lvalue_const_bitset()
{
    static std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const clset = std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;();
    return clset;
}
</pre>
<p>The <tt class="docutils literal">U::evaluate_category</tt> static member
function template has a simple job: to return the correct value category when
passed in an object returned by one of the functions defined above.  Assume
that <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is defined.</p>
<pre class="first literal-block">
enum invoked
{
    passed_by_lvalue_reference_to_const
  , passed_by_lvalue_reference
  , passed_by_rvalue_reference_to_const
  , passed_by_rvalue_reference
};

struct U
{
    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;)
    {
        return passed_by_lvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;)
    {
        return passed_by_lvalue_reference;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt; const&amp;&amp;)
    {
        return passed_by_rvalue_reference_to_const;
    }

    template &lt;std::size_t N&gt;
    static invoked evaluate_category(std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/bitset"
>bitset</a>&lt;N + 1&gt;&amp;&amp;)
    {
        return passed_by_rvalue_reference;
    }
};
</pre>
<p>Named parameters are required when invoking the constructor; however, none
of their tags need to be in the same namespace.</p>
<pre class="first literal-block">
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lrc, kw0) in(lrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_lr, kw1) in_out(lr))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rrc, kw2) in(rrc))
<a class="reference internal" href="#boost-parameter-name-name"
>BOOST_PARAMETER_NAME</a>((_rr, kw3) consume(rr))
</pre>
<p>Unlike <a class="reference internal"
href="#boost-parameter-no-spec-constructor-cls-impl"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_CONSTRUCTOR</tt></a>, this
macro doesn't require a base class, only a delegate function to which the
generated constructor can pass its <a class="reference internal"
href="#argumentpack"><span class="concept">ArgumentPack</span></a>.</p>
<pre class="first literal-block">
struct D
{
    BOOST_PARAMETER_NO_SPEC_NO_BASE_CONSTRUCTOR(D, D::_evaluate)

 private:
    template &lt;typename Args&gt;
    static bool _evaluate(Args const&amp; args)
    {
        BOOST_TEST_EQ(
            passed_by_lvalue_reference_to_const
          , U::evaluate_category&lt;0&gt;(args[_lrc])
        );
        BOOST_TEST_EQ(
            passed_by_lvalue_reference
          , U::evaluate_category&lt;1&gt;(args[_lr])
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference_to_const
          , U::evaluate_category&lt;2&gt;(
                args[_rrc0 | rvalue_const_bitset&lt;2&gt;()]
            )
        );
        BOOST_TEST_EQ(
            passed_by_rvalue_reference
          , U::evaluate_category&lt;3&gt;(
                args[_rr0 | rvalue_bitset&lt;3&gt;()]
            )
        );

        return true;
    }
};
</pre>
<p>To invoke the constructor, bind all its arguments to named parameters.</p>
<pre class="first literal-block">
D dp0(
    _rr0 = rvalue_bitset&lt;3&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
  , _lr0 = lvalue_bitset&lt;1&gt;()
  , _rrc0 = rvalue_const_bitset&lt;2&gt;()
);
D dp1(
    _lr0 = lvalue_bitset&lt;1&gt;()
  , _lrc0 = lvalue_const_bitset&lt;0&gt;()
);
</pre>
<p>The <a class="reference external"
href="../../test/preprocessor_eval_cat_no_spec.cpp"
>test/preprocessor_eval_cat_no_spec.cpp</a> test program demonstrates proper
usage of this macro.</p>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Macro parameters:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">
<ul class="last simple">
<li><tt class="docutils literal">cls</tt> is the name of the enclosing
class.</li>
<li><tt class="docutils literal">func</tt> is a function that takes in the
<a class="reference internal" href="#argumentpack"><span class="concept"
>ArgumentPack</span></a> that the generated constructor passes on.</li>
</ul>
</td>
</tr>
<tr class="field">
<th class="field-name" colspan="2">Argument specifiers syntax:</th>
</tr>
<tr>
<td>&nbsp;</td>
<td class="field-body">None.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dd>
<pre class="last literal-block">
template &lt;
    template <
        typename TaggedArg0
      , typename ...TaggedArgs
      , typename = typename boost::<a class="reference external"
href="../../../core/doc/html/core/enable_if.html">enable_if</a>&lt;
            <a class="reference internal" href="#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0,TaggedArgs...&gt;
        &gt;::type
&gt;
inline explicit <strong>cls</strong>(
    TaggedArg0 const&amp; arg0
  , TaggedArgs const&amp;... args
)
{
    <strong>func</strong>(<a class="reference internal" href="compose"
>compose</a>(arg0, args...));
}
</pre>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-name-name">
<h2><a class="toc-backref" href="#id74">7.19&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_NAME(name)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/name.hpp">boost/parameter/name.hpp</a></td>
</tr>
</tbody>
</table>
<p>Declares a tag-type and keyword object.</p>
<p><strong>If</strong> <em>name</em> is of the form:</p>
<pre class="literal-block">
(<em>object-name</em>, <em>namespace-name</em>) <em>qualifier</em>(<em
>tag-name</em>)
</pre>
<p><strong>then</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">
<p class="first"><em>qualifier</em> is either <tt class="docutils literal"
>in</tt>, <tt class="docutils literal">out</tt>, <tt class="docutils literal"
>in_out</tt>, <tt class="docutils literal">consume</tt>, <tt
class="docutils literal">move_from</tt>, or <tt class="docutils literal"
>forward</tt>.</p>
</td>
</tr>
</tbody>
</table>
<p>Expands to:</p>
<pre class="literal-block">
namespace <em>namespace-name</em> {

    struct <em>tag-name</em>
    {
        static constexpr char const* keyword_name()
        {
            return ##<em>tag-name</em>;
        }

        typedef <em>unspecified</em> _;
        typedef <em>unspecified</em> _1;
        typedef boost::parameter::<em>qualifier</em> ## _reference qualifier;
    };
}

<a class="reference internal" href="#keyword">keyword</a>&lt;<em
>tag-namespace</em>::<em>tag-name</em>&gt; const&amp; <em>object-name</em>
    = <a class="reference internal" href="#keyword">keyword</a>&lt;<em
>tag-namespace</em>::<em>tag-name</em>&gt;::instance;
</pre>
<p><strong>Else If</strong> <em>name</em> is of the form:</p>
<pre class="literal-block">
(<em>object-name</em>, <em>namespace-name</em>) <em>tag-name</em>
</pre>
<p><strong>then</strong></p>
<p>Treats <em>name</em> as if it were of the form:</p>
<pre class="literal-block">
(<em>object-name</em>, <em>namespace-name</em>) forward(<em>tag-name</em>)
</pre>
<p><strong>Else If</strong> <em>name</em> is of the form:</p>
<pre class="literal-block">
<em>qualifier</em>(<em>tag-name</em>)
</pre>
<p><strong>then</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">
<p class="first"><em>qualifier</em> is either <tt class="docutils literal"
>in</tt>, <tt class="docutils literal">out</tt>, <tt class="docutils literal"
>in_out</tt>, <tt class="docutils literal">consume</tt>, <tt
class="docutils literal">move_from</tt>, or <tt class="docutils literal"
>forward</tt>.</p>
</td>
</tr>
</tbody>
</table>
<p>Expands to:</p>
<pre class="literal-block">
namespace tag {

    struct <em>tag-name</em>
    {
        static constexpr char const* keyword_name()
        {
            return ##<em>tag-name</em>;
        }

        typedef <em>unspecified</em> _;
        typedef <em>unspecified</em> _1;
        typedef boost::parameter::<em>qualifier</em> ## _reference qualifier;
    };
}

<a class="reference internal" href="#keyword">keyword</a>&lt;tag::<em
>tag-name</em>&gt; const&amp; _ ## <em>tag-name</em>
    = <a class="reference internal" href="#keyword">keyword</a>&lt;tag::<em
>tag-name</em>&gt;::instance;
</pre>
<p><strong>Else</strong></p>
<p>Treats <em>name</em> as if it were of the form:</p>
<pre class="literal-block">
forward(<em>tag-name</em>)
</pre>
</div>
<div class="section" id="boost-parameter-nested-keyword-t-n-a">
<h2><a class="toc-backref" href="#id75">7.20&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_NESTED_KEYWORD(tag_namespace, name,
alias)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/nested_keyword.hpp"
>boost/parameter/nested_keyword.hpp</a></td>
</tr>
</tbody>
</table>
<p>Declares a tag-type, a keyword object, and an alias for that object nested
in the tag-type.</p>
<p><strong>If</strong> <em>name</em> is of the form:</p>
<pre class="literal-block">
<em>qualifier</em>(<em>tag-name</em>)
</pre>
<p><strong>then</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">
<p class="first"><em>qualifier</em> is either <tt class="docutils literal"
>in</tt>, <tt class="docutils literal">out</tt>, <tt class="docutils literal"
>in_out</tt>, <tt class="docutils literal">consume</tt>, <tt
class="docutils literal">move_from</tt>, or <tt class="docutils literal"
>forward</tt>.</p>
</td>
</tr>
</tbody>
</table>
<p>Expands to:</p>
<pre class="literal-block">
namespace tag {

    struct <em>tag-name</em>
    {
        static constexpr char const* keyword_name()
        {
            return ##<em>tag-name</em>;
        }

        typedef <em>unspecified</em> _;
        typedef <em>unspecified</em> _1;
        typedef boost::parameter::<em>qualifier</em> ## _reference qualifier;
        static <a class="reference internal" href="#keyword"
>keyword</a>&lt;<em>tag-name</em>&gt; const& <em>alias</em>;
    };

    <a class="reference internal" href="#keyword">keyword</a>&lt;<em
>tag-name</em>&gt; const& <em>tag-name</em>::<em>alias</em>
        = <a class="reference internal" href="#keyword">keyword</a>&lt;<em
>tag-name</em>&gt;::instance;
}

<a class="reference internal" href="#keyword">keyword</a>&lt;tag::<em
>tag-name</em>&gt; const&amp; <em>name</em>
    = <a class="reference internal" href="#keyword">keyword</a>&lt;tag::<em
>tag-name</em>&gt;::instance;
</pre>
<p><strong>Else</strong></p>
<p>Treats <em>name</em> as if it were of the form:</p>
<pre class="literal-block">
forward(<em>tag-name</em>)
</pre>
</div>
<div class="section" id="boost-parameter-template-keyword-name">
<h2><a class="toc-backref" href="#id76">7.21&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_TEMPLATE_KEYWORD(name)</tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/template_keyword.hpp"
>boost/parameter/template_keyword.hpp</a></td>
</tr>
<tr class="field">
<th class="field-name">Included by:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/name.hpp">boost/parameter/name.hpp</a></td>
</tr>
</tbody>
</table>
<p>Expands to:</p>
<pre class="literal-block">
namespace tag {

    struct <em>name</em>;
}

template &lt;typename T&gt;
struct <em>name</em> : <a class="reference internal" href="#template-keyword"
>template_keyword</a>&lt;tag::<em>name</em>, T&gt;
{
};
</pre>
<p>The <a class="reference external"
href="../../test/function_type_tpl_param.cpp"
>test/function_type_tpl_param.cpp</a> test program demonstrates proper usage
of this macro.</p>
</div>
<div class="section" id="boost-parameter-fun-r-n-l-h-p">
<h2><a class="toc-backref" href="#id77">7.22&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_FUN(r, n, l, h, p)</tt></a></h2>
<div class="admonition-deprecated admonition">
<p class="first admonition-title">Deprecated</p>
<p class="last">This macro has been deprecated in favor of
<a class="reference internal"
href="#boost-parameter-function-result-name-tag-namespace-arguments"
><tt class="docutils literal">BOOST_PARAMETER_FUNCTION</tt></a>.</p>
</div>
<p>Generates a sequence of <a class="reference external"
href="index.html#forwarding-functions">forwarding function</a> templates named
<tt class="docutils literal">n</tt>, with arities ranging from
<tt class="docutils literal">l</tt> to <tt class="docutils literal">h</tt>,
returning <tt class="docutils literal">r</tt>, and using
<tt class="docutils literal">p</tt> to control overload resolution and assign
tags to positional arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/macros.hpp"
>boost/parameter/macros.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body"><tt class="docutils literal">l</tt> and <tt
class="docutils literal">h</tt> are nonnegative integer tokens such that <tt
class="docutils literal">l</tt> &lt; <tt class="docutils literal">h</tt></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Expands to:</dt>
<dd>
<pre class="first last literal-block">
template &lt;typename A1, typename A2, …, typename A ## <strong>l</strong>&gt;
r
    name(
        A1&amp;&amp; a1, A2&amp;&amp; a2, …, A ## <strong
>l</strong> &amp;&amp; a ## <strong>l</strong>
      , typename <strong>p</strong>::match&lt;A1, A2, …, A ## <strong
>l</strong>&gt;::type pk = <strong>p</strong>()
    )
{
    return <strong>name</strong>_with_named_params(
        pk(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A1&gt;(a1)
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A2&gt;(a2)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>l</strong>&gt;(a ## <strong>l</strong>)
        )
    );
}

template &lt;
    typename A1
  , typename A2
  , …
  , typename A ## <strong>l</strong>
  , typename A ## <a class="reference external"
href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong
>l</strong>)
&gt;
r
    name(
        A1&amp;&amp; a1, A2&amp;&amp; a2, …, A ## <strong
>l</strong> &amp;&amp; a ## <strong>l</strong>
      , A ## <a class="reference external"
href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong
>l</strong>) &amp;&amp; a ## <a class="reference external"
href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong
>l</strong>)
      , typename <strong>p</strong>::match&lt;A1, A2, …, A<strong
>l</strong>, A ## <a class="reference external"
href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong
>l</strong>)&gt;::type pk = <strong>p</strong>())
{
    return <strong>name</strong>_with_named_params(
        pk(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A1&gt;(a1)
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A2&gt;(a2)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>l</strong>&gt;(a ## <strong>l</strong>)
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <a class="reference external"
href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong
>l</strong>)&gt;(a ## <a class="reference external"
href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong
>l</strong>))
        )
    );
}

<span class="vellipsis">⋮</span>

template &lt;typename A1, typename A2, …, typename A ## <strong>h</strong>&gt;
r
    name(
        A1&amp;&amp; a1, A2&amp;&amp; a2, …, A ## <strong
>h</strong> &amp;&amp; a ## <strong>h</strong>
      , typename <strong>p</strong>::match&lt;A1, A2, …, A ## <strong
>h</strong>&gt;::type pk = <strong>p</strong>()
    )
{
    return <strong>name</strong>_with_named_params(
        pk(
            std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A1&gt;(a1)
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A2&gt;(a2)
          , …
          , std::<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/forward"
>forward</a>&lt;A ## <strong>h</strong>&gt;(a ## <strong>h</strong>)
        )
    );
}
</pre>
</dd>
</dl>
<p>The <a class="reference external" href="../../test/macros.cpp"
>test/macros.cpp</a> and <a class="reference external"
href="../../test/macros_eval_category.cpp">test/macros_eval_category.cpp</a>
test programs demonstrate proper usage of this macro.</p>
</div>
<div class="section" id="boost-parameter-keyword-n-k">
<h2><a class="toc-backref" href="#id78">7.23&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_KEYWORD(n, k)</tt></a></h2>
<div class="admonition-deprecated admonition">
<p class="first admonition-title">Deprecated</p>
<p class="last">This macro has been deprecated in favor of
<a class="reference internal" href="#boost-parameter-name-name"><tt
class="docutils literal">BOOST_PARAMETER_NAME</tt></a>.</p>
</div>
<p>Generates the declaration of a <a class="reference internal"
href="#keyword-tag-type">keyword tag type</a> named
<tt class="docutils literal">k</tt> in namespace
<tt class="docutils literal">n</tt>, and a corresponding
<a class="reference internal" href="#keyword-object">keyword object</a>
definition in the enclosing namespace.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/keyword.hpp"
>boost/parameter/keyword.hpp</a></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Generates</dt>
<dd><pre class="first last literal-block">
namespace <strong>n</strong> {

    struct <strong>k</strong>
    {
        static constexpr char const* keyword_name()
        {
            return ##<em>k</em>;
        }

        typedef <em>unspecified</em> _;
        typedef <em>unspecified</em> _1;
        typedef boost::parameter::forward_reference qualifier;
    };
}

namespace {

    <a class="reference internal" href="#keyword">keyword</a>&lt;<em
>n</em>::<strong>k</strong>&gt; const&amp; <strong>k</strong>
        = <a class="reference internal" href="#keyword">keyword</a>&lt;<em
>n</em>::<strong>k</strong>&gt;::instance;
}
</pre>
</dd>
</dl>
</div>
<div class="section" id="boost-parameter-match-p-a-x">
<h2><a class="toc-backref" href="#id79">7.24&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_MATCH(p, a, x)</tt></a></h2>
<p>Generates a defaulted parameter declaration for a
<a class="reference external"
href="index.html#forwarding-functions">forwarding function</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/match.hpp"
>boost/parameter/match.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Requires:</th>
<td class="field-body">
<p class="first"><tt class="docutils literal">a</tt> is a
<a class="reference external" href="../../../preprocessor/doc/data.html"
>Boost.Preprocessor sequence</a> of the form</p>
<pre class="last literal-block">
(A0)(A1)…(A<em>n</em>)
</pre>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Generates</dt>
<dd>
<pre class="first last literal-block">
    typename <strong>p</strong>::match&lt;<strong>A0</strong>, <strong
>A1</strong>, …, <strong>A</strong> ## <em>n</em>&gt;::type
        <strong>x</strong> = <strong>p</strong>()
</pre>
</dd>
</dl>
</div>
</div>
<div class="section" id="configuration-macros">
<h1><a class="toc-backref" href="#id80">8&nbsp;&nbsp;&nbsp;Configuration
Macros</a></h1>
<div class="section" id="boost-parameter-has-perfect-forwarding">
<h2><a class="toc-backref" href="#id81">8.1&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a></h2>
<p>Determines whether or not the library supports perfect forwarding, or the
preservation of parameter value categories.  Users can manually disable this
macro by <tt class="docutils literal">#defining</tt> the <a
class="reference internal" href="#boost-parameter-disable-perfect-forwarding"
><tt class="docutils literal">BOOST_PARAMETER_DISABLE_PERFECT_FORWARDING</tt
></a> macro.  Otherwise, the library will <tt class="docutils literal"
>#define</tt> this macro if and only if it is not already defined, and if the
configuration macros <a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_FUNCTION_TEMPLATE_ORDERING</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_SFINAE</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_RVALUE_REFERENCES</tt></a>, and
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_VARIADIC_TEMPLATES</tt></a> are
not already defined by <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/config.hpp"
>boost/parameter/config.hpp</a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="boost-parameter-disable-perfect-forwarding">
<h2><a class="toc-backref" href="#id82">8.2&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_DISABLE_PERFECT_FORWARDING</tt></a
></h2>
<p>It may be necessary to test user code in case perfect forwarding support is
unavailable.  Users can <tt class="docutils literal">#define</tt> this macro
either in their project settings or before including any library header
files.  Doing so will leave both <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> and <a
class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> undefined.</p>
</div>
<div class="section" id="boost-parameter-can-use-mp11">
<h2><a class="toc-backref" href="#id83">8.3&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a></h2>
<p>Determines whether or not the library can use <a class="reference external"
href="../../../mp11/doc/html/mp11.html">Boost.MP11</a>, a C++11
metaprogramming library.  Users can manually disable
this macro by <tt class="docutils literal">#defining</tt> the <a
class="reference internal" href="#boost-parameter-disable-mp11-usage"><tt
class="docutils literal">BOOST_PARAMETER_DISABLE_MP11_USAGE</tt></a> macro or
the <a class="reference internal"
href="#boost-parameter-disable-perfect-forwarding"><tt
class="docutils literal">BOOST_PARAMETER_DISABLE_PERFECT_FORWARDING</tt></a>
macro.  Otherwise, the library will <tt class="docutils literal">#define</tt>
this macro if and only if it is not already defined, if <a
class="reference internal" href="#boost-parameter-has-perfect-forwarding"><tt
class="docutils literal">BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is
defined, and if the configuration macros <a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_CONSTEXPR</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_DECLTYPE_N3276</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_AUTO_DECLARATIONS</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_TEMPLATE_ALIASES</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_STATIC_ASSERT</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_HDR_TYPE_TRAITS</tt></a>,
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_HDR_INITIALIZER_LIST</tt></a>,
and <a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_HDR_TUPLE</tt></a> are not
already defined by <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/config.hpp"
>boost/parameter/config.hpp</a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="boost-parameter-disable-mp11-usage">
<h2><a class="toc-backref" href="#id84">8.4&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_DISABLE_MP11_USAGE</tt></a></h2>
<p>It may be necessary to disable usage of <a class="reference external"
href="../../../mp11/doc/html/mp11.html">Boost.MP11</a> for compilers that
cannot support it.  Users can <tt class="docutils literal">#define</tt> this
macro either in their project settings or before including any library header
files.  Doing so will leave <a class="reference internal"
href="#boost-parameter-can-use-mp11"><tt class="docutils literal"
>BOOST_PARAMETER_CAN_USE_MP11</tt></a> undefined.</p>
</div>
<div class="section" id="boost-parameter-variadic-mpl-sequence">
<h2><a class="toc-backref" href="#id85">8.5&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_VARIADIC_MPL_SEQUENCE</tt></a></h2>
<p>If <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is
<tt class="docutils literal">#defined</tt>, then determines the
<a class="reference external"
href="../../../mpl/doc/refmanual/variadic-sequence.html">MPL Variadic
Sequence</a> underlying the nested <tt class="docutils literal"
>parameter_spec</tt> type of <a class="reference internal" href="#parameters"
><tt class="docutils literal">parameters</tt></a>.  If the user does not
manually <tt class="docutils literal">#define</tt> this macro, then the
library will <tt class="docutils literal">#define</tt> it as
<a class="reference external" href="../../../mp11/doc/html/mp11.html"
><tt class="docutils literal">boost::mp11::mp_list</tt></a> if
<a class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> is defined,
<a class="reference external"
href="../../../fusion/doc/html/fusion/container/list.html"
><tt class="docutils literal">boost::fusion::list</tt></a> if
<a class="reference external"
href="../../../../boost/fusion/container/list/list_fwd.hpp"
><tt class="docutils literal">BOOST_FUSION_HAS_VARIADIC_LIST</tt></a> is
defined (by <a class="reference external"
href="../../../fusion/doc/html/index.html">Boost.Fusion</a>),
<a class="reference external"
href="../../../fusion/doc/html/fusion/container/deque.html"
><tt class="docutils literal">boost::fusion::deque</tt></a> if
<a class="reference external"
href="../../../../boost/fusion/container/deque/deque_fwd.hpp"
><tt class="docutils literal">BOOST_FUSION_HAS_VARIADIC_DEQUE</tt></a> is
defined (by <a class="reference external"
href="../../../fusion/doc/html/index.html">Boost.Fusion</a>), or
<a class="reference external" href="../../../mpl/doc/refmanual/vector.html"
><tt class="docutils literal">boost::mpl::vector</tt></a> otherwise.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd>
<pre class="first last literal-block">
#define BOOST_PARAMETER_VARIADIC_MPL_SEQUENCE <a class="reference external"
href="../../../fusion/doc/html/fusion/container/vector.html"
>boost::fusion::vector</a>
</pre>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/parameters.hpp"
>boost/parameter/parameters.hpp</a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="boost-parameter-max-arity">
<h2><a class="toc-backref" href="#id86">8.6&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_MAX_ARITY</tt></a></h2>
<p>If <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is
<tt class="docutils literal">#defined</tt>, then:</p>
<ul>
<li>If the <a class="reference external"
href="../../../mpl/doc/refmanual/variadic-sequence.html">MPL Variadic
Sequence</a> underlying the nested <tt class="docutils literal"
>parameter_spec</tt> type of <a class="reference internal" href="#parameters"
><tt class="docutils literal">parameters</tt></a> does not have a size
limit--which is the case with <a class="reference external"
href="../../../mp11/doc/html/mp11.html"><tt class="docutils literal"
>boost::mp11::mp_list</tt></a>, <a class="reference external"
href="../../../fusion/doc/html/fusion/container/list.html"
><tt class="docutils literal">boost::fusion::list</tt></a>, and
<a class="reference external"
href="../../../fusion/doc/html/fusion/container/deque.html"
><tt class="docutils literal">boost::fusion::deque</tt></a>, but not
<a class="reference external"
href="../../../mpl/doc/refmanual/vector.html"
><tt class="docutils literal">boost::mpl::vector</tt></a>--then this macro
can be safely ignored.  User code that manually defines
<a class="reference internal" href="#boost-parameter-variadic-mpl-sequence"
><tt class="docutils literal">BOOST_PARAMETER_VARIADIC_MPL_SEQUENCE</tt></a>
should also manually define this macro to the size limit of the sequence if it
has one.</li>
</ul>
<p>If <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is <strong>not</strong>
<tt class="docutils literal">#defined</tt>, then:</p>
<ul>
<li>Mutable references must be wrapped by
<a class="reference external" href="../../../core/doc/html/core/ref.html"
><tt class="docutils literal">boost::ref</tt></a> or
<a class="reference external"
href="http://en.cppreference.com/w/cpp/utility/functional/ref"
><tt class="docutils literal">std::ref</tt></a> if passed by position to
Boost.Parameter-enabled functions with arity greater than or equal to
<a class="reference internal"
href="#boost-parameter-exponential-overload-threshold-arity"
><tt class="docutils literal"
>BOOST_PARAMETER_EXPONENTIAL_OVERLOAD_THRESHOLD_ARITY</tt></a>.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/config.hpp"
>boost/parameter/config.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Default Value:</th>
<td class="field-body"><a class="reference external"
href="../../../mpl/doc/refmanual/limit-vector-size.html"
><tt class="docutils literal">BOOST_MPL_LIMIT_VECTOR_SIZE</tt></a> (defined by
<a class="reference external" href="../../../mpl/doc/index.html"
>Boost.MPL</a>) if perfect forwarding is supported,
<tt class="docutils literal">8</tt> otherwise.</td>
</tr>
<tr class="field">
<th class="field-name">Minimum Value:</th>
<td class="field-body"><tt class="docutils literal">2</tt></td>
</tr>
<tr class="field">
<th class="field-name">Maximum Value:</th>
<td class="field-body"><a class="reference internal"
href="#boost-parameter-compose-max-arity"><tt class="docutils literal"
>BOOST_PARAMETER_COMPOSE_MAX_ARITY</tt></a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="boost-parameter-compose-max-arity">
<h2><a class="toc-backref" href="#id87">8.7&nbsp;&nbsp;&nbsp;<tt
class="docutils literal">BOOST_PARAMETER_COMPOSE_MAX_ARITY</tt></a></h2>
<p>If <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> is <strong>not</strong>
<tt class="docutils literal">#defined</tt>, then determines the maximum number
of arguments supported by the <a class="reference internal" href="#compose"
><tt class="docutils literal">compose</tt></a> function and by the <a
class="reference internal"
href="#boost-parameter-no-spec-function-result-name"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_FUNCTION</tt></a>, <a
class="reference internal"
href="#boost-parameter-no-spec-member-function-result-name"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_MEMBER_FUNCTION</tt></a>, <a
class="reference internal"
href="#boost-parameter-no-spec-c-mem-function-result-name"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_CONST_MEMBER_FUNCTION</tt></a
>, <a class="reference internal"
href="#boost-parameter-no-spec-function-call-op-result"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_FUNCTION_CALL_OPERATOR</tt
></a>, <a class="reference internal"
href="#boost-parameter-no-spec-const-func-call-op-result"><tt
class="docutils literal"
>BOOST_PARAMETER_NO_SPEC_CONST_FUNCTION_CALL_OPERATOR</tt></a>, <a
class="reference internal"
href="#boost-parameter-no-spec-constructor-cls-impl"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_CONSTRUCTOR</tt></a>, and <a
class="reference internal"
href="#boost-parameter-no-spec-no-base-ctor-cls-func"><tt
class="docutils literal">BOOST_PARAMETER_NO_SPEC_NO_BASE_CONSTRUCTOR</tt></a>
code generation macros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/config.hpp"
>boost/parameter/config.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Default Value:</th>
<td class="field-body"><tt class="docutils literal">20</tt> for a few older
compilers, <tt class="docutils literal">64</tt> otherwise</td>
</tr>
<tr class="field">
<th class="field-name">Minimum Value:</th>
<td class="field-body"><tt class="docutils literal">2</tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="boost-parameter-exponential-overload-threshold-arity"
><h2><a class="toc-backref" href="#id88">8.8&nbsp;&nbsp;&nbsp;<tt
class="docutils literal"
>BOOST_PARAMETER_EXPONENTIAL_OVERLOAD_THRESHOLD_ARITY</tt></a></h2>
<p>If this library does <strong>not</strong> support perfect forwarding,
determines the number of arguments less than which
<a class="reference internal" href="#parameters"><tt class="docutils literal"
>parameters</tt></a> generates an exponential number of function call operator
overloads, and greater than or equal to which <a class="reference internal"
href="#parameters"><tt class="docutils literal">parameters</tt></a> does
not.  Will only be <tt class="docutils literal">#defined</tt> by the library
if it is not already <tt class="docutils literal">#defined</tt> and
<a class="reference internal" href="#boost-parameter-has-perfect-forwarding"
><tt class="docutils literal">BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a>
is <strong>not</strong> <tt class="docutils literal">#defined</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Defined in:</th>
<td class="field-body"><a class="reference external"
href="../../../../boost/parameter/config.hpp"
>boost/parameter/config.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field">
<th class="field-name">Default Value:</th>
<td class="field-body"><tt class="docutils literal">0</tt></td>
</tr>
<tr class="field">
<th class="field-name">Minimum Value:</th>
<td class="field-body"><tt class="docutils literal">0</tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="outside-of-this-library"
><h2><a class="toc-backref" href="#id89">8.9&nbsp;&nbsp;&nbsp;...Outside Of
This Library</a></h2>
<ol>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_FUNCTION_TEMPLATE_ORDERING</tt></a>, then
the macros <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> and <a
class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined; otherwise, the code generation macros would not work
correctly.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_SFINAE</tt></a>, then the macros <a
class="reference internal" href="#boost-parameter-has-perfect-forwarding"><tt
class="docutils literal">BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> and
<a class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined; otherwise, keyword types generated by <a class="reference internal"
href="#boost-parameter-name-name"><tt class="docutils literal"
>BOOST_PARAMETER_NAME</tt></a> and <a class="reference internal"
href="#boost-parameter-nested-keyword-t-n-a"><tt class="docutils literal"
>BOOST_PARAMETER_NESTED_KEYWORD</tt></a> would not work correctly.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_RVALUE_REFERENCES</tt></a>, then the
macros <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> and <a
class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_VARIADIC_TEMPLATES</tt></a>, then the
macros <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> and <a
class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS</tt></a
>, then the macros <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a> and <a
class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_CONSTEXPR</tt></a>, then the macro <a
class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_DECLTYPE_N3276</tt></a>, then the
macro <a class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"
><tt class="docutils literal">BOOST_NO_CXX11_AUTO_DECLARATIONS</tt></a>, then
the macro <a class="reference internal" href="#boost-parameter-can-use-mp11"
><tt class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be
left undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_TEMPLATE_ALIASES</tt></a>, then the
macro <a class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_STATIC_ASSERT</tt></a>, then the
macro <a class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_HDR_TYPE_TRAITS</tt></a>, then the
macro <a class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_HDR_INITIALIZER_LIST</tt></a>, then
the macro <a class="reference internal" href="#boost-parameter-can-use-mp11"
><tt class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be
left undefined.</li>
<li>If <a class="reference external"
href="../../../config/doc/html/index.html">Boost.Config</a> defines the macro
<a class="reference external"
href="../../../config/doc/html/boost_config/boost_macro_reference.html"><tt
class="docutils literal">BOOST_NO_CXX11_HDR_TUPLE</tt></a>, then the macro <a
class="reference internal" href="#boost-parameter-can-use-mp11"><tt
class="docutils literal">BOOST_PARAMETER_CAN_USE_MP11</tt></a> will be left
undefined.</li>
<li>If <a class="reference external"
href="../../../fusion/doc/html/index.html">Boost.Fusion</a> defines the macro
<a class="reference external"
href="../../../../boost/fusion/container/list/list_fwd.hpp"
><tt class="docutils literal">BOOST_FUSION_HAS_VARIADIC_LIST</tt></a>, if
this library defines the macro <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a>, and if the macro
<a class="reference internal" href="#boost-parameter-variadic-mpl-sequence"
><tt class="docutils literal">BOOST_PARAMETER_VARIADIC_MPL_SEQUENCE</tt></a>
is left undefined, then the <a class="reference external"
href="../../../mpl/doc/refmanual/variadic-sequence.html">MPL Variadic
Sequence</a> underlying the nested <tt class="docutils literal"
>parameter_spec</tt> type of <a class="reference internal" href="#parameters"
><tt class="docutils literal">parameters</tt></a> will be
<a class="reference external"
href="../../../fusion/doc/html/fusion/container/list.html"
><tt class="docutils literal">boost::fusion::list</tt></a>.</li>
<li>If <a class="reference external"
href="../../../fusion/doc/html/index.html">Boost.Fusion</a> defines the macro
<a class="reference external"
href="../../../../boost/fusion/container/deque/deque_fwd.hpp"
><tt class="docutils literal">BOOST_FUSION_HAS_VARIADIC_DEQUE</tt></a>, if
this library defines the macro <a class="reference internal"
href="#boost-parameter-has-perfect-forwarding"><tt class="docutils literal"
>BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a>, and if the macro
<a class="reference internal" href="#boost-parameter-variadic-mpl-sequence"
><tt class="docutils literal">BOOST_PARAMETER_VARIADIC_MPL_SEQUENCE</tt></a>
is left undefined, then the <a class="reference external"
href="../../../mpl/doc/refmanual/variadic-sequence.html">MPL Variadic
Sequence</a> underlying the nested <tt class="docutils literal"
>parameter_spec</tt> type of <a class="reference internal" href="#parameters"
><tt class="docutils literal">parameters</tt></a> will be
<a class="reference external"
href="../../../fusion/doc/html/fusion/container/deque.html"
><tt class="docutils literal">boost::fusion::deque</tt></a>.</li>
<li>The value that <a class="reference external"
href="../../../mpl/doc/index.html">Boost.MPL</a> defines the macro
<a class="reference external"
href="../../../mpl/doc/refmanual/limit-vector-size.html"
><tt class="docutils literal">BOOST_MPL_LIMIT_VECTOR_SIZE</tt></a> as will be
the value that this library defines the macro <a class="reference internal"
href="#boost-parameter-max-arity"><tt class="docutils literal"
>BOOST_PARAMETER_MAX_ARITY</tt></a> as if this library defines the macro
<a class="reference internal" href="#boost-parameter-has-perfect-forwarding"
><tt class="docutils literal">BOOST_PARAMETER_HAS_PERFECT_FORWARDING</tt></a
>.</li>
</ol>
</div>
</div>
<div class="section" id="tutorial">
<h1><a class="toc-backref" href="#id90">9&nbsp;&nbsp;&nbsp;Tutorial</a></h1>
<p>Follow <a class="reference external" href="index.html#tutorial">this
link</a> to the Boost.Parameter tutorial documentation.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="thread" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
<td>References to tag objects may be initialized multiple times.  This
scenario can only occur in the presence of threading.  Because the C++
standard doesn't consider threading, it doesn't explicitly allow or forbid
multiple initialization of references.  That said, it's hard to imagine an
implementation where it could make a difference.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="no-result-of" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label">[2]</td>
<td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref"
href="#id18">2</a>)</em> Where <a class="reference external"
href="../../../utility/utility.htm#BOOST_NO_RESULT_OF"><tt
class="docutils literal">BOOST_NO_RESULT_OF</tt></a> is <tt
class="docutils literal">#defined</tt>, <tt class="docutils literal"
>boost::</tt><a class="reference external"
href="../../../utility/utility.htm#result_of"><tt class="docutils literal"
>result_of</tt></a><tt class="docutils literal">&lt;F()&gt;::type</tt> is
replaced by <tt class="docutils literal">F::result_type</tt>.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2011-11-08 21:40 UTC.  Generated by <a
class="reference external" href="http://docutils.sourceforge.net/"
>Docutils</a> from <a class="reference external"
href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
