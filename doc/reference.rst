++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
The Boost Parameter Library Reference Documentation
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

:Authors:       David Abrahams, Daniel Wallin
:Contact:       dave@boost-consulting.com, daniel@boostpro.com
:organization:  `BoostPro Computing`_
:date:          $Date: 2005/07/17 19:53:01 $

:copyright:     Copyright David Abrahams, Daniel Wallin
                2005-2009.  Distributed under the Boost Software License,
                Version 1.0.  (See accompanying file LICENSE_1_0.txt
                or copy at http://www.boost.org/LICENSE_1_0.txt)

|(logo)|__

.. |(logo)| image:: ../../../../boost.png
    :alt: Boost

__ ../../../../index.htm

.. _`BoostPro Computing`: http://www.boostpro.com


//////////////////////////////////////////////////////////////////////////////

.. contents::
    :depth: 2

//////////////////////////////////////////////////////////////////////////////

.. role:: class
    :class: class

.. role:: concept
    :class: concept

.. role:: function
    :class: function

.. |ArgumentPack| replace:: :concept:`ArgumentPack`
.. |ForwardSequence| replace:: :concept:`Forward Sequence`
.. |ParameterSpec| replace:: :concept:`ParameterSpec`

.. role:: vellipsis
    :class: vellipsis

.. section-numbering::
    :depth: 2

Preliminaries
=============

This section covers some basic information you'll need to know in order to
understand this reference.

Namespaces
----------

In this document, all unqualified identifiers should be assumed to be defined
in namespace ``boost::parameter`` unless otherwise specified.

Exceptions
----------

No operation described in this document throws an exception unless otherwise
specified.

Thread Safety
-------------

All components of this library can be used safely from multiple threads
without synchronization.  [#thread]_

Typography
----------

Names written in :concept:`sans serif type` represent concepts_.

In code blocks, *italic type* represents unspecified text that satisfies the
requirements given in the detailed description that follows the code block.

In a specification of the tokens generated by a macro, **bold type** is used
to highlight the position of the expanded macro argument in the result.

The special character β represents the value of |BOOST_PARAMETER_MAX_ARITY|_.

//////////////////////////////////////////////////////////////////////////////

Terminology
===========

.. |kw| replace:: keyword
.. _kw:

keyword
    The name of a function parameter.

.. _keyword tag type:
.. |keyword tag type| replace:: `keyword tag type`_

keyword tag type
    A type used to uniquely identify a function parameter.  Typically its name
    will be the same as that of the parameter.

.. _positional:
.. |positional| replace:: `positional`_

positional argument
    An argument passed with no explicit |kw|.  Its parameter is determined
    in the usual C++ way: by position with respect to a parameter list.

.. _tag type:
.. |tag type| replace:: `tag type`_

tag type
    Shorthand for “\ |keyword tag type|.”

.. _keyword object:
.. |keyword object| replace:: `keyword object`_

keyword object
    An instance of |keyword|_ ``<T>`` for some |tag type| ``T``.

.. _tagged reference:
.. |tagged reference| replace:: `tagged reference`_

tagged reference
    An object whose type is associated with a |keyword tag type| (the object's
    *keyword*), and that holds a reference (to the object's *value*).  

    As a shorthand, a “tagged reference to ``x``\ ” means a tagged reference
    whose *value* is ``x``.

.. _tagged default:
.. |tagged default| replace:: `tagged default`_

tagged default
    A |tagged reference| whose *value* represents the value of a
    default argument. 

.. _tagged lazy default:
.. |tagged lazy default| replace:: `tagged lazy default`_

tagged lazy default
    A |tagged reference| whose *value*, when invoked with no arguments,
    computes a default argument value.

.. _intended argument type:
.. |intended argument type| replace:: `intended argument type`_

intended argument type
    The *intended argument type* of a single-element |ArgumentPack|_ is the
    type of its element's *value*.  The intended argument type of any other
    type ``X`` is ``X`` itself.

.. Note::

    In this reference, we will use concept names (and other names) to describe
    both types and objects, depending on context.  So for example, “an
    |ArgumentPack|_\ ” can refer to a type that models |ArgumentPack|_
    *or* an object of such a type.

//////////////////////////////////////////////////////////////////////////////

Concepts
========

This section describes the generic type concepts_ used by the Parameter
library.

.. _concepts: http://www.boost.org/more/generic_programming.html#concept

|ArgumentPack|
--------------

An |ArgumentPack| is a collection of |tagged reference|\ s to the actual
arguments passed to a function.  Every |ArgumentPack| is also a valid MPL
|ForwardSequence|__ consisting of the |keyword tag type|\ s in its
|tagged reference|\ s.

__ ../../../mpl/doc/refmanual/forward-sequence.html

Requirements
............

In the table below, 

* ``A`` is a model of |ArgumentPack|
* ``x`` is an instance of ``A``
* ``u`` is a |keyword object| of type ``K``
* ``v`` is a |tagged default| with |tag type| ``L`` and *value* of type ``D``
* ``w`` is a |tagged lazy default| with |tag type| ``M`` and *value* of type
    ``E const``
* ``z`` is an |ArgumentPack| containing a single element (as created by
    |keyword|_\ ``<…>::operator=``)

Any exceptions thrown from the invocation of ``w``\ 's *value*
will be propagated to the caller.

.. table:: |ArgumentPack| requirements

+------------+-------------------+----------------+--------------------------+
| Expression | Type              | Requirements   | Semantics/Notes          |
+============+===================+================+==========================+
|  ``x[u]``  | ``binding<``      | ``x`` contains | Returns *b*\ 's *value*  |
|            |     ``A, K``      | an element *b* | (by reference).          |
|            | ``>::type``       | whose |kw|_ is |                          |
|            |                   | ``K``          |                          |
+------------+-------------------+----------------+--------------------------+
|  ``x[u]``  | ``binding<``      | *none*         | If ``x`` contains an     |
|            |     ``A, L, D``   |                | element *b* whose |kw|_  |
|            | ``>::type``       |                | is the same as           |
|            |                   |                | ``u``\ 's, returns       |
|            |                   |                | *b*\ 's *value* (by      |
|            |                   |                | reference).  Otherwise,  |
|            |                   |                | returns ``u``\ 's        |
|            |                   |                | *value*.                 |
+------------+-------------------+----------------+--------------------------+
|  ``x[w]``  | ``lazy_binding<`` | *none*         | If ``x`` contains an     |
|            |     ``A, M, E``   |                | element *b* whose |kw|_  |
|            | ``>::type``       |                | is the same as           |
|            |                   |                | ``w``\ 's, returns       |
|            |                   |                | *b*\ 's *value* (by      |
|            |                   |                | reference).  Otherwise,  |
|            |                   |                | invokes ``w``\ 's        |
|            |                   |                | *value* and returns the  |
|            |                   |                | result.                  |
+------------+-------------------+----------------+--------------------------+
|  ``x, z``  | Model of          | *none*         | Returns an               |
|            | |ArgumentPack|    |                | |ArgumentPack|_          |
|            |                   |                | containing all the       |
|            |                   |                | elements of both ``x``   |
|            |                   |                | and ``z``.               |
+------------+-------------------+----------------+--------------------------+

.. _parameterspec:

|ParameterSpec|
---------------

A |ParameterSpec| describes the type requirements for arguments corresponding
to a given |kw|_ and indicates whether the argument is optional or
required.  The table below details the allowed forms and describes their
condition for satisfaction by an actual argument type. In each row,

.. _conditions:

* ``K`` is the |ParameterSpec|\ 's |keyword tag type|
* ``A`` is an |intended argument type| associated with ``K``, if any
* ``P`` is a model of |ArgumentPack| that contains ``A``
* ``F`` is an `MPL Binary Metafunction Class`_

.. _`MPL Binary Metafunction Class`: ../../../mpl/doc/refmanual/metafunction-class.html

.. table:: |ParameterSpec| allowed forms and conditions of satisfaction

+------------------------+----------+----------------------------------------+
| Type                   | ``A``    | Condition ``A`` must satisfy           |
|                        | required |                                        |
+========================+==========+========================================+
| ``K``                  | no       |       *n/a*                            |
+------------------------+----------+----------------------------------------+
| |optional|_\ ``<K,F>`` | no       | ``mpl::apply2<F,A,P>::type::value`` is |
|                        |          | ``true``.                              |
+------------------------+----------+----------------------------------------+
| |required|_\ ``<K,F>`` | yes      | ``mpl::apply2<F,A,P>::type::value`` is |
|                        |          | ``true``.                              |
+------------------------+----------+----------------------------------------+

The information in a |ParameterSpec| is used to `limit`__ the arguments that
will be matched by `forwarding functions`_.  

__ overloadcontrol_
.. _overloadcontrol: index.html#controlling-overload-resolution
.. _forwarding functions: index.html#forwarding-functions

//////////////////////////////////////////////////////////////////////////////

Class Templates
===============

.. |keyword| replace:: ``keyword``
.. _keyword:

``keyword``
-----------

The type of every |keyword object| is a specialization of |keyword|.

:Defined in: `boost/parameter/keyword.hpp`__

__ ../../../../boost/parameter/keyword.hpp

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**

.. parsed-literal::

    template <typename Tag>
    struct keyword
    {
        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`true_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::in_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , |ArgumentPack|_
        >::type constexpr
            `operator=`_\(T const& value) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                typename boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::out_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >::type
              , boost::mpl::`if_`_<
                    std::`is_const`_<T>
                  , boost::mpl::`false_`_
                  , boost::mpl::`true_`_
                >
              , boost::mpl::`false_`_
            >::type
          , |ArgumentPack|_
        >::type constexpr
            `operator=`_\(T& value) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`false_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::in_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , |ArgumentPack|_
        >::type constexpr
            `operator=`_\(T const&& value) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`false_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::consume_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , |ArgumentPack|_
        >::type constexpr
            `operator=`_\(T&& value) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`true_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::in_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , *tagged default*
        >::type
            `operator|`_\(T const& x) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                typename boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::out_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >::type
              , boost::mpl::`if_`_<
                    std::`is_const`_<T>
                  , boost::mpl::`false_`_
                  , boost::mpl::`true_`_
                >
              , boost::mpl::`false_`_
            >::type
          , *tagged default*
        >::type
            `operator|`_\(T& x) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`true_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::in_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , *tagged default*
        >::type
            `operator|`_\(T const&& x) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`false_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::consume_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , *tagged default*
        >::type constexpr
            `operator|`_\(T&& value) const;

        template <typename F>
        *tagged lazy default* `operator||`_\(F const&) const;

        template <typename F>
        *tagged lazy default* `operator||`_\(F&) const;

        static keyword<Tag> const& instance;

        static keyword<Tag>& get_\();
    };

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is **not** ``#defined``,
**then**

.. parsed-literal::

    template <typename Tag>
    struct keyword
    {
        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`true_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::in_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , |ArgumentPack|_
        >::type constexpr
            `operator=`_\(T const& value) const;

        template <typename T>
        typename boost::`enable_if`_<
            boost::mpl::`and_`_<
                boost::mpl::`or_`_<
                    boost::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::out_reference
                    >
                  , boost::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    >
                >
              , boost::mpl::`not_`_<boost::`is_const`_<T> >
            >
          , |ArgumentPack|_
        >::type constexpr
            `operator=`_\(T& value) const;

        template <typename T>
        typename boost::`enable_if`_<
            typename boost::mpl::`eval_if_`_<
                std::`is_scalar`_<T>
              , boost::mpl::`true_`_
              , boost::mpl::`eval_if_`_<
                    std::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::in_reference
                    >
                  , boost::mpl::`true_`_
                  , boost::mpl::`if_`_<
                        std::`is_same`_<
                            typename Tag::qualifier
                          , boost::parameter::forward_reference
                        >
                      , boost::mpl::`true_`_
                      , boost::mpl::`false_`_
                    >
                >
            >::type
          , *tagged default*
        >::type
            `operator|`_\(T const& x) const;

        template <typename T>
        typename boost::`enable_if`_<
            boost::mpl::`and_`_<
                boost::mpl::`or_`_<
                    boost::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::out_reference
                    >
                  , boost::`is_same`_<
                        typename Tag::qualifier
                      , boost::parameter::forward_reference
                    >
                >
              , boost::mpl::`not_`_<boost::`is_const`_<T> >
            >
          , *tagged default*
        >::type
            `operator|`_\(T& x) const;

        template <typename F>
        *tagged lazy default* `operator||`_\(F const&) const;

        template <typename F>
        *tagged lazy default* `operator||`_\(F&) const;

        static keyword<Tag> const& instance;

        static keyword<Tag>& get_\();
    };

.. _enable_if: ../../../core/doc/html/core/enable_if.html
.. _eval_if_: ../../../mpl/doc/refmanual/eval-if.html
.. _false_: ../../../mpl/doc/refmanual/bool.html
.. _if_: ../../../mpl/doc/refmanual/if.html
.. _is_const: http://en.cppreference.com/w/cpp/types/is_const
.. _is_same: http://en.cppreference.com/w/cpp/types/is_same
.. _is_scalar: http://en.cppreference.com/w/cpp/types/is_scalar
.. _true_: ../../../mpl/doc/refmanual/bool.html

.. |operator=| replace:: ``operator=``
.. _operator=:

``operator=``
.. parsed-literal::

    template <typename T> |ArgumentPack|_ operator=(T const& value) const;
    template <typename T> |ArgumentPack|_ operator=(T& value) const;

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**
.. parsed-literal::

    template <typename T> |ArgumentPack|_ operator=(T const&& value) const;
    template <typename T> |ArgumentPack|_ operator=(T&& value) const;

:Requires: one of the following:

\*. The nested ``qualifier`` type of ``Tag`` must be ``forward_reference``.

\*. To use the ``const`` lvalue reference overload, ``T`` must be scalar, or
the nested ``qualifier`` type of ``Tag`` must be ``in_reference``.

\*. To use the mutable lvalue reference overload, the nested ``qualifier``
type of ``Tag`` must be ``out_reference`` or ``in_out_reference``, and ``T``
must not be ``const``-qualified.

\*. To use the ``const`` rvalue reference overload for non-scalar ``T``, the
nested ``qualifier`` type of ``Tag`` must be ``in_reference``.

\*. To use the mutable rvalue reference overload for non-scalar ``T``, the
nested ``qualifier`` type of ``Tag`` must be ``consume_reference`` or
``move_from_reference``.

:Returns: an |ArgumentPack|_  containing a single |tagged reference| to
``value`` with |kw|_ ``Tag`` 

.. _operator|:

``operator|``
.. parsed-literal::

    template <typename T> *tagged default* operator|(T const& x) const;
    template <typename T> *tagged default* operator|(T& x) const;

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**
.. parsed-literal::

    template <typename T> *tagged default* operator|(T const&& x) const;
    template <typename T> *tagged default* operator|(T&& x) const;

:Requires: one of the following:

\*. The nested ``qualifier`` type of ``Tag`` must be ``forward_reference``.

\*. To use the ``const`` lvalue reference overload, ``T`` must be scalar, or
the nested ``qualifier`` type of ``Tag`` must be ``in_reference``.

\*. To use the mutable lvalue reference overload, the nested ``qualifier``
type of ``Tag`` must be ``out_reference`` or ``in_out_reference``, and ``T``
must not be ``const``-qualified.

\*. To use the ``const`` rvalue reference overload for non-scalar ``T``, the
nested ``qualifier`` type of ``Tag`` must be ``in_reference``.

\*. To use the mutable rvalue reference overload for non-scalar ``T``, the
nested ``qualifier`` type of ``Tag`` must be ``consume_reference`` or
``move_from_reference``.

:Returns: a |tagged default| with *value* ``x`` and |kw|_ ``Tag``.

.. _operator||:

``operator||``
.. parsed-literal::

    template <typename F> *tagged lazy default* operator||(F const& g) const;
    template <typename F> *tagged lazy default* operator||(F& g) const;

:Requires: ``g()`` must be valid, with type ``boost::``\ |result_of|_\
``<F()>::type``.  [#no_result_of]_

:Returns: a |tagged lazy default| with *value* ``g`` and |kw|_ ``Tag``.

.. _instance:

``instance``
.. parsed-literal::

    static keyword<Tag> const& instance;

:Returns: a “singleton instance”: the same object will be returned on each
invocation of ``instance``.

:Thread Safety:
``instance`` can be accessed from multiple threads simultaneously.

.. _get:

``get``
.. parsed-literal::

    static keyword<Tag>& get\();

.. admonition:: Deprecated

    This function has been deprecated in favor of ``instance``.

:Returns: a “singleton instance”: the same object will be returned on each
invocation of ``get()``.

:Thread Safety: ``get()`` can be called from multiple threads simultaneously.

``parameters``
--------------

Provides an interface for assembling the actual arguments to a
`forwarding function` into an |ArgumentPack|, in which any
|positional| arguments will be tagged according to the
corresponding template argument to ``parameters``.  

.. _forwarding function: `forwarding functions`_

:Defined in: `boost/parameter/parameters.hpp`__

__ ../../../../boost/parameter/parameters.hpp

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**

    template <typename ...PSpec>
    struct parameters
    {
        template <typename ...Args>
        struct `match`_
        {
            typedef … type;
        };

        template <typename ...Args>
        |ArgumentPack|_ `operator()`_\(Args&&... args) const;
    };

:Requires: Each element in the ``PSpec`` parameter pack must be a model of
|ParameterSpec|_.

.. Note::

    In this section, ``R`` ## *i* and ``K`` ## *i* are defined as
    follows, for any argument type ``A`` ## *i*:

    | let ``D0`` the set [d0, …, d ## *j*] of all **deduced**
    | *parameter specs* in the ``PSpec`` parameter pack
    | ``R`` ## *i* is the |intended argument type| of ``A`` ## *i*
    |
    | if ``A`` ## *i* is a result type of ``keyword<T>::`` |operator=|_
    | then 
    |     ``K`` ## *i* is ``T``
    | else
    |     if some ``A`` ## *j* where *j* ≤ *i* is a result type of
    |     ``keyword<T>::`` |operator=|_
    |     *or* some ``P`` ## *j* in *j* ≤ *i* is **deduced**
    |     then
    |         if some *parameter spec* ``d`` ## *j* in ``D`` ## *i*
    |         matches ``A`` ## *i*
    |         then
    |             ``K`` ## *i* is the |keyword tag type| of ``d`` ## *j*.
    |             ``D``:sub:`i+1` is ``D`` ## *i* - [ ``d`` ## *j*]
    |     else
    |         ``K`` ## *i* is the |keyword tag type| of ``P`` ## *i*.

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is **not** ``#defined``,
**then**

.. parsed-literal::

    template <
        typename P0 = *unspecified*
      , typename P1 = *unspecified*
      , …
      , typename P ## β = *unspecified*
    >
    struct parameters
    {
        template <
            typename A0
          , typename A1 = *unspecified*
          , …
          , typename A ## β = *unspecified*
        >
        struct `match`_
        {
            typedef … type;
        };

        template <typename A0>
        |ArgumentPack|_ `operator()`_\(A0& a0) const;

        template <typename A0, typename A1>
        |ArgumentPack|_ `operator()`_\(A0& a0, A1& a1) const;

        :vellipsis:`⋮`

        template <typename A0, typename A1, …, typename A ## β>
        |ArgumentPack|_
        `operator()`_\(A0& a0, A1& a1, …, A ## β & a ## β) const;
    };

:Requires: ``P0``, ``P1``, …, ``P`` ## β must be models of |ParameterSpec|_.

.. Note::

    In this section, ``R`` ## *i* and ``K`` ## *i* are defined as follows: for
    any argument type ``A`` ## *i*:

    | let ``D0`` the set [ d0, …, d ## *j*] of all **deduced**
    | *parameter specs* in [ ``P0``, …, ``P`` ## β]
    | ``R`` ## *i* is the |intended argument type| of ``A`` ## *i*
    |
    | if ``A`` ## *i* is a result type of ``keyword<T>::`` |operator=|_
    | then 
    |     ``K`` ## *i* is ``T``
    | else
    |     if some ``A`` ## *j* where *j* ≤ *i* is a result type of
    |     ``keyword<T>::`` |operator=|_
    |     *or* some ``P`` ## *j* in *j* ≤ *i* is **deduced**
    |     then
    |         if some *parameter spec* ``d`` ## *j* in ``D`` ## *i*
    |         matches ``A`` ## *i*
    |         then
    |             ``K`` ## *i* is the |keyword tag type| of ``d`` ## *j*.
    |             ``D``:sub:`i+1` is ``D`` ## *i* - [ ``d`` ## *j*]
    |     else
    |         ``K`` ## *i* is the |keyword tag type| of ``P`` ## *i*.

.. _match:

``match``
    A |Metafunction|_ used to remove a `forwarding function`_ from overload
    resolution.

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**

:Returns: if all elements in ``Params...`` are *satisfied* (see below), then
``parameters<Params...>``.  Otherwise, ``match<Args...>::type`` is not
defined.

Each element ``P`` in ``Params...`` is **satisfied** if either:

* ``P`` is the *unspecified* default
* **or**, ``P`` is a *keyword tag type*
* **or**, ``P`` is |optional|_ ``<X,F>`` and either
    - ``X`` is not ``K`` ## *i* for any *i*,
    - **or** ``X`` is some ``K`` ## *i*  and ``mpl::apply<F,R`` ## *i*\
        ``>::type::value`` is ``true``
* **or**, ``P`` is |required|_ ``<X,F>``, and
    - ``X`` is some ``K`` ## *i*, **and**
    - ``mpl::apply<F,R`` ## *i* ``>::type::value`` is ``true``

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is **not** ``#defined``,
**then**

:Returns: if ``P0``, ``P1``, …, ``Pβ`` are *satisfied* (see below), then
``parameters<P0,P1,…,Pβ>``.  Otherwise, ``match<A0,A1,…,Aβ>::type`` is not
defined.

``P0``, ``P1``, …, ``Pβ`` are **satisfied** if, for every *j* in 0…β,
either:

* ``P`` ## *j* is the *unspecified* default
* **or**, ``P`` ## *j* is a *keyword tag type*
* **or**, ``P`` ## *j* is |optional|_ ``<X,F>`` and either
    - ``X`` is not ``K`` ## *i* for any *i*,
    - **or** ``X`` is some ``K`` ## *i*  and ``mpl::apply<F,R`` ## *i*\
        ``>::type::value`` is ``true``
* **or**, ``P`` ## *j* is |required|_ ``<X,F>``, and
    - ``X`` is some ``K`` ## *i*, **and**
    - ``mpl::apply<F,R`` ## *i* ``>::type::value`` is ``true``

.. _operator():

``operator()``

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**

.. parsed-literal::

    template <typename ...Args>
    |ArgumentPack|_ operator()(Args&&... args) const;

**Else**

.. parsed-literal::

    template <typename A0> |ArgumentPack|_ operator()(A0 const& a0) const;

    :vellipsis:`⋮`

    template <typename A0, …, typename A ## β>
    |ArgumentPack|_
    `operator()`_\(A0 const& a0, …, A ## β const& a ## β) const;

:Returns: An |ArgumentPack|_ containing, for each ``a`` ## *i*,  

    - if ``a`` ## *i*  is a single-element |ArgumentPack|, its element
    - Otherwise, a |tagged reference| with |kw|_ ``K`` ## *i* and *value*
        ``a`` ## *i*

.. |optional| replace:: ``optional``
.. |required| replace:: ``required``

.. _optional:
.. _required:

``optional``, ``required``
--------------------------

These templates describe the requirements on a function parameter.

:Defined in: `boost/parameter/parameters.hpp`__

__ ../../../../boost/parameter/parameters.hpp

:Specializations model: |ParameterSpec|_

.. parsed-literal::

    template <typename Tag, typename Predicate = *unspecified*>
    struct optional;

    template <typename Tag, typename Predicate = *unspecified*>
    struct required;

The default value of ``Predicate`` is an unspecified `MPL Binary Metafunction
Class`_ that returns ``mpl::true_`` for any argument.

.. _`MPL Binary Metafunction Class`: ../../../mpl/doc/refmanual/metafunction-class.html

``deduced``
-----------

This template is used to wrap the *keyword tag* argument to
``optional`` or ``required``.

:Defined in: `boost/parameter/parameters.hpp`__

__ ../../../../boost/parameter/parameters.hpp

.. parsed-literal::

    template <typename Tag>
    struct deduced;

:Requires: nothing

//////////////////////////////////////////////////////////////////////////////

Metafunctions
=============

A |Metafunction|_ is conceptually a function that operates on, and returns,
C++ types.

``binding``
-----------

Returns the result type of indexing an argument pack with a
|keyword tag type| or with a |tagged default|.

:Defined in: `boost/parameter/binding.hpp`__

__ ../../../../boost/parameter/binding.hpp

.. parsed-literal::

    template <typename A, typename K, typename D = void\_>
    struct binding
    {
        typedef … type;
    };

:Requires: ``A`` must be a model of |ArgumentPack|_.

:Returns: the reference type of the |tagged reference| in ``A`` having
|keyword tag type| ``K``, if any.  If no such |tagged reference| exists,
returns ``D``.

``lazy_binding``
----------------

Returns the result type of indexing an argument pack with a
|tagged lazy default|.

:Defined in: `boost/parameter/binding.hpp`__

__ ../../../../boost/parameter/binding.hpp

.. parsed-literal::

    template <typename A, typename K, typename F>
    struct lazy_binding
    {
        typedef … type;
    };

:Requires: ``A`` must be a model of |ArgumentPack|_.

:Returns: the reference type of the |tagged reference| in ``A`` having
|keyword tag type| ``K``, if any.  If no such |tagged reference| exists,
returns ``boost::``\ |result_of|_\ ``<F()>::type``. [#no_result_of]_

``value_type``
--------------

Returns the result type of indexing an argument pack with a
|keyword tag type| or with a |tagged default|.

:Defined in: `boost/parameter/value_type.hpp`__

__ ../../../../boost/parameter/value_type.hpp

.. parsed-literal::

    template <typename A, typename K, typename D = void\_>
    struct value_type
    {
        typedef … type;
    };

:Requires: ``A`` must be a model of |ArgumentPack|_.

:Returns: the (possibly const-qualified) type of the |tagged reference| in
``A`` having |keyword tag type| ``K``, if any.  If no such |tagged reference|
exists, returns ``D``. Equivalent to::

    typename remove_reference<
        typename binding<A, K, D>::type
    >::type

… when ``D`` is not a reference type.

//////////////////////////////////////////////////////////////////////////////

Code Generation Macros
======================

Macros in this section can be used to ease the writing of code
using the Parameter library by eliminating repetitive boilerplate.

``BOOST_PARAMETER_FUNCTION(result, name, tag_namespace, arguments)``
--------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

:Requires: ``result`` is the parenthesized return type of the
function.  ``name`` is the base name of the function; it determines the name
of the generated forwarding functions.  ``tag_namespace`` is the namespace in
which the keywords used by the function resides.  ``arguments`` is a
`Boost.Preprocessor`_ `sequence`_ of *argument-specifiers*, as defined below.

:Argument specifiers syntax:
.. parsed-literal::

    argument-specifiers ::= *specifier-group0* {*specifier-group0*\ }

    specifier-group0 ::= *specifier-group1* |
        (
            '**(**' '**deduced**'
                *specifier-group1* {*specifier-group1*\ }
            '**)**'
        )

    specifier-group1 ::=
        (
            '**(**' '**optional**'
                *optional-specifier* {*optional-specifier*\ }
            '**)**'
        ) | (
            '**(**' '**required**'
                *required-specifier* {*required-specifier*\ }
            '**)**'
        )

    optional-specifier ::=
        '**(**'
            *argument-name* '**,**' *restriction* '**,**' *default-value*
        ')'

    required-specifier ::=
        '**(**' *argument-name* '**,**' *restriction* ')'

    restriction ::=
        ( '**\***' '**(**' *mfc* '**)**' ) |
        ( '**(**' *type-name* '**)**' ) |
        '**\***'

* ``argument-name`` is any valid C++ identifier.
* ``default-value`` is any valid C++ expression; if necessary, user code can
compute it in terms of ``previous-name ## _type``, where ``previous-name`` is
the ``argument-name`` in a previous ``specifier-group0`` or
``specifier-group1``.  *This expression will be invoked exactly once.*
* ``mfc`` is an `MPL Binary Metafunction Class`_ whose first argument will be
the type of the corresponding ``argument-name``, whose second argument will be
the entire |ArgumentPack|_, and whose return type is a `Boolean Integral
Constant`_; however, user code *cannot* compute ``mfc`` in terms of
``previous-name ## _type``.
* ``type-name`` is either the name of a **target type** or an `MPL Binary
Metafunction Class`_ whose first argument will be the type of the
corresponding ``argument-name``, whose second argument will be the entire
|ArgumentPack|_, and whose return type is the **target type**.  If
``restriction`` uses this form, then the type of the generated name
``argument-name ## _type`` will be computed in terms of the **target type**,
and the generated reference ``argument-name`` (but not its corresponding entry
in ``args``) will be cast to that type.

.. _`Boost.Preprocessor`: ../../../preprocessor/doc/index.html
.. _`sequence`: ../../../preprocessor/doc/data/sequences.html
.. _`MPL Binary Metafunction Class`: ../../../mpl/doc/refmanual/metafunction-class.html
.. _`Boolean Integral Constant`: ../../../mpl/doc/refmanual/integral-constant.html

:Generated names in enclosing scope:
* ``boost_param_result_ ## __LINE__ ## name``
* ``boost_param_params_ ## __LINE__ ## name``
* ``boost_param_parameters_ ## __LINE__ ## name``
* ``boost_param_impl ## name``
* ``boost_param_dispatch_0boost_ ## __LINE__ ## name``
* ``boost_param_dispatch_1boost_ ## __LINE__ ## name``

Approximate expansion:
**Where**:

* ``n`` denotes the *minimum* arity, as determined from ``arguments``.
* ``m`` denotes the *maximum* arity, as determined from ``arguments``.

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**

.. parsed-literal::

    template <typename T>
    struct boost_param_result\_ ## __LINE__ ## **name**
    {
        typedef **result** type;
    };

    struct boost_param_params\_ ## __LINE__ ## **name**
      : boost::parameter::parameters<
            *list of parameter specifications, based on arguments*
        >
    {
    };

    typedef boost_param_params\_ ## __LINE__ ## **name** 
        boost_param_parameters\_ ## __LINE__ ## **name**;

    template <typename Args>
    typename boost_param_result\_ ## __LINE__ ## **name**\ <Args>::type
        boost_param_impl ## **name**\ (Args const&);

    template <typename A0, …, typename A ## **n**>
    **result** **name**\ (
        A0&& a0, …, A ## **n**\ && a ## **n**
      , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
            A0, …, A ## **n**
        >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
    )
    {
        return boost_param_impl ## **name**\ (
            boost_param_parameters\_ ## __LINE__ ## **name**\ ()(
                boost::`forward`_<A0>(a0)
              , …
              , boost::`forward`_<A ## **n**>(a ## **n**)
            )
        );
    }

    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **m**>
    **result** **name**\ (
        A0&& a0, …, A ## **m**\ && a ## **m**
      , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
            A0, …, A ## **m**
        >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
    )
    {
        return boost_param_impl ## **name**\ (
            boost_param_parameters\_ ## __LINE__ ## **name**\ ()(
                boost::`forward`_<A0>(a0)
              , …
              , boost::`forward`_<A ## **m**>(a ## **m**)
            )
        );
    }

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **n** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type&& *argument name* ## **0**
          , …
          , *argument name* ## **n** ## _type&& *argument name* ## **m**
        );

    :vellipsis:`⋮`

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **m** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type&& *argument name* ## **0**
          , …
          , *argument name* ## **m** ## _type&& *argument name* ## **m**
        );

    template <typename Args>
    typename boost_param_result\_ ## __LINE__ ## **name**\ <Args>::type
        boost_param_impl ## **name**\ (Args const& args)
    {
        return boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            static_cast<ResultType(\ *)()>(std::nullptr)
          , args
          , boost::`forward`_<
                typename boost::parameter::value_type<
                    Args
                  , *keyword tag type of required parameter* ## **0**
                >::type
            >(args[ *keyword object of required parameter* ## **0**])
          , …
          , boost::`forward`_<
                typename boost::parameter::value_type<
                    Args
                  , *keyword tag type of required parameter* ## **n**
                >::type
            >(args[ *keyword object of required parameter* ## **n**])
        );
    }

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **n** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type&& *argument name* ## **0**
          , …
          , *argument name* ## **n** ## _type&& *argument name* ## **n**
        )
    {
        return boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            static_cast<ResultType(\ *)()>(std::nullptr)
          , (args, *keyword object of optional parameter* ## **n + 1** =
                *default value of optional parameter* ## **n + 1**
            )
          , boost::`forward`_<*argument name* ## **0** ## _type>(
                *argument name* ## **0**
            )
          , …
          , boost::`forward`_<*argument name* ## **n** ## _type>(
                *argument name* ## **n**
            )
          , boost::`forward`_<
                typename boost::parameter::value_type<
                    Args
                  , *keyword tag type of optional parameter* ## **n + 1**
                >::type
            >(*default value of optional parameter* ## **n + 1**)
        );
    }

    :vellipsis:`⋮`

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **m** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type&& *argument name* ## **0**
          , …
          , *argument name* ## **m** ## _type&& *argument name* ## **m**
        )

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is **not** ``#defined``,
**then**

.. parsed-literal::

    template <typename T>
    struct boost_param_result\_ ## __LINE__ ## **name**
    {
        typedef **result** type;
    };

    struct boost_param_params\_ ## __LINE__ ## **name**
      : boost::parameter::parameters<
            *list of parameter specifications, based on arguments*
        >
    {
    };

    typedef boost_param_params\_ ## __LINE__ ## **name** 
        boost_param_parameters\_ ## __LINE__ ## **name**;

    template <typename Args>
    typename boost_param_result\_ ## __LINE__ ## **name**\ <Args>::type
        boost_param_impl ## **name**\ (Args const&);

    template <typename A0, …, typename A ## **n**>
    **result**
        **name**\ (
            A0 const& a0, …, A ## **n** const& a ## **n**
          , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
                A0 const, …, A ## **n** const
            >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
        )
    {
        return boost_param_impl ## **name**\ (
            boost_param_parameters\_ ## __LINE__ ## **name**\ ()(
                a0, …, a ## **n**
            )
        );
    }

    *… exponential number of overloads …*
    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **n**>
    **result**
        **name**\ (
            A0& a0, …, A ## **n** & a ## **n**
          , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
                A0, …, A ## **n**
            >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
        )
    {
        return boost_param_impl ## **name**\ (
            boost_param_parameters\_ ## __LINE__ ## **name**\ ()(
                a0, …, a ## **n**
            )
        );
    }

    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **m**>
    **result**
        **name**\ (
            A0 const& a0, …, A ## **m** const& a ## **m**
          , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
                A0 const, …, A ## **m** const
            >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
        )
    {
        return boost_param_impl ## **name**\ (
            boost_param_parameters\_ ## __LINE__ ## **name**\ ()(
                a0, …, a ## **m**
            )
        );
    }

    *… exponential number of overloads …*
    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **m**>
    **result**
        **name**\ (
            A0& a0, …, A ## **m** & a ## **m**
          , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
                A0, …, A ## **m**
            >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
        )
    {
        return boost_param_impl ## **name**\ (
            boost_param_parameters\_ ## __LINE__ ## **name**\ ()(
                a0, …, a ## **m**
            )
        );
    }

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **n** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type& *argument name* ## **0**
          , …
          , *argument name* ## **n** ## _type& *argument name* ## **m**
        );

    :vellipsis:`⋮`

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **m** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type& *argument name* ## **0**
          , …
          , *argument name* ## **m** ## _type& *argument name* ## **m**
        );

    template <typename Args>
    typename boost_param_result\_ ## __LINE__ ## **name**\ <Args>::type
        boost_param_impl ## **name**\ (Args const& args)
    {
        return boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            static_cast<ResultType(\ *)()>(std::nullptr)
          , args
          , args[ *keyword object of required parameter* ## **0**]
          , …
          , args[ *keyword object of required parameter* ## **n**]
        );
    }

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **n** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type& *argument name* ## **0**
          , …
          , *argument name* ## **n** ## _type& *argument name* ## **m**
        )
    {
        return boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            static_cast<ResultType(\ *)()>(std::nullptr)
          , (args, *keyword object of optional parameter* ## **n + 1** =
                *default value of optional parameter* ## **n + 1**
            )
          , *argument name* ## **0**
          , …
          , *argument name* ## **n**
          , *default value of optional parameter* ## **n + 1**
        );
    }

    :vellipsis:`⋮`

    template <
        typename ResultType
      , typename Args
      , typename *argument name* ## **0** ## _type
      , …
      , typename *argument name* ## **m** ## _type
    >
    ResultType
        boost_param_dispatch_0boost\_ ## __LINE__ ## **name**\ (
            (ResultType(\ *)())
          , Args const& args
          , *argument name* ## **0** ## _type& *argument name* ## **0**
            :vellipsis:`⋮`
          , *argument name* ## **m** ## _type& *argument name* ## **m**
        )

The |preprocessor|_, |preprocessor_deduced|_, and |preprocessor_eval_cat|_
test programs demonstrate proper usage of this macro.

.. |preprocessor| replace:: preprocessor.cpp
.. _preprocessor: ../../test/preprocessor.cpp
.. |preprocessor_deduced| replace:: preprocessor_deduced.cpp
.. _preprocessor_deduced: ../../test/preprocessor_deduced.cpp
.. |preprocessor_eval_cat| replace:: preprocessor_eval_category.cpp
.. _preprocessor_eval_cat: ../../test/preprocessor_eval_category.cpp

``BOOST_PARAMETER_MEMBER_FUNCTION(result, name, tag_namespace, arguments)``
---------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

Same as ``BOOST_PARAMETER_FUNCTION``, except:

\*. ``name`` may be qualified by the ``static`` keyword to declare the member
function and its helpers as not associated with any object of the enclosing
type.

\*. Expansion of this macro omits all forward declarations of the front-end
implementation and dispatch functions.

The |preprocessor|_ and |preprocessor_eval_cat|_ test programs demonstrate
proper usage of this macro.

.. |preprocessor| replace:: preprocessor.cpp
.. _preprocessor: ../../test/preprocessor.cpp
.. |preprocessor_eval_cat| replace:: preprocessor_eval_category.cpp
.. _preprocessor_eval_cat: ../../test/preprocessor_eval_category.cpp

``BOOST_PARAMETER_CONST_MEMBER_FUNCTION(result, name, tag_ns, arguments)``
--------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

Same as ``BOOST_PARAMETER_MEMBER_FUNCTION``, except that the overloaded
forwarding member functions and their helper methods are
``const``-qualified.

The |preprocessor|_ test programs demonstrates proper usage of this macro.

.. |preprocessor| replace:: preprocessor.cpp
.. _preprocessor: ../../test/preprocessor.cpp

``BOOST_PARAMETER_FUNCTION_CALL_OPERATOR(result, tag_namespace, arguments)``
----------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

Same as ``BOOST_PARAMETER_MEMBER_FUNCTION``, except that the name of the
forwarding member function overloads is ``operator()``.

:Generated names in enclosing scope:
* ``boost_param_result_ ## __LINE__ ## operator``
* ``boost_param_params_ ## __LINE__ ## operator``
* ``boost_param_parameters_ ## __LINE__ ## operator``
* ``boost_param_impl ## operator``
* ``boost_param_dispatch_0boost_ ## __LINE__ ## operator``
* ``boost_param_dispatch_1boost_ ## __LINE__ ## operator``

``BOOST_PARAMETER_CONST_FUNCTION_CALL_OPERATOR(result, tag_ns, arguments)``
---------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

Same as ``BOOST_PARAMETER_FUNCTION_CALL_OPERATOR``, except that the overloaded
function call operators and their helper methods are ``const``-qualified.

The |preprocessor_eval_cat_8|_ test program demonstrates proper usage of this
macro.

.. |preprocessor_eval_cat_8| replace:: preprocessor_eval_cat_8.cpp
.. _preprocessor_eval_cat_8: ../../test/preprocessor_eval_cat_8.cpp

``BOOST_PARAMETER_CONSTRUCTOR(cls, impl, tag_namespace, arguments)``
--------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

:Requires: ``cls`` is the name of the enclosing class.  ``impl`` is the
parenthesized implementation base class for ``cls``.  ``tag_namespace`` is the
namespace in which the keywords used by the function resides.  ``arguments``
is a list of *argument-specifiers*, as defined in ``BOOST_PARAMETER_FUNCTION``
except that *optional-specifier* no longer includes *default-value*.  It is up
to the delegate constructor in ``impl`` to determine the default value of all
optional arguments.

:Generated names in enclosing scope:
* ``boost_param_params_ ## __LINE__ ## ctor``
* ``constructor_parameters ## __LINE__``

Approximate expansion:
**Where**:

* ``n`` denotes the *minimum* arity, as determined from ``arguments``.
* ``m`` denotes the *maximum* arity, as determined from ``arguments``.

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**

.. parsed-literal::

    struct boost_param_params\_ ## __LINE__ ## ctor
      : boost::parameter::parameters<
            *list of parameter specifications, based on arguments*
        >
    {
    };

    typedef boost_param_params\_ ## __LINE__ ## **name**
        constructor_parameters ## __LINE__;

    template <typename A0, …, typename A ## **n**>
    *cls*\ (A0&& a0, …, A ## **n** && a ## **n**)
      : *impl*\ (
            constructor_parameters ## __LINE__(
                boost::`forward`_<A0>(a0)
              , …
              , boost::`forward`_<A ## **n**>(a ## **n**)
            )
        )
    {
    }

    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **m**>
    *cls*\ (A0&& a0, …, A ## **m** && a ## **m**)
      : *impl*\ (
            constructor_parameters ## __LINE__(
                boost::`forward`_<A0>(a0)
              , …
              , boost::`forward`_<A ## **m**>(a ## **m**)
            )
        )
    {
    }

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is **not** ``#defined``,
**then**

.. parsed-literal::

    struct boost_param_params\_ ## __LINE__ ## ctor
      : boost::parameter::parameters<
            *list of parameter specifications, based on arguments*
        >
    {
    };

    typedef boost_param_params\_ ## __LINE__ ## **name**
        constructor_parameters ## __LINE__;

    template <typename A0, …, typename A ## **n**>
    *cls*\ (A0 const& a0, …, A ## **n** const& a ## **n**)
      : *impl*\ (constructor_parameters ## __LINE__(a0, …, a ## **n**))
    {
    }

    *… exponential number of overloads …*
    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **n**>
    *cls*\ (A0& a0, …, A ## **n** & a ## **n**)
      : *impl*\ (constructor_parameters ## __LINE__(a0, …, a ## **n**))
    {
    }

    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **m**>
    *cls*\ (A0 const& a0, …, A ## **m** const& a ## **m**)
      : *impl*\ (constructor_parameters ## __LINE__(a0, …, a ## **m**))
    {
    }

    *… exponential number of overloads …*
    :vellipsis:`⋮`

    template <typename A0, …, typename A ## **m**>
    *cls*\ (A0& a0, …, A ## **m** & a ## **m**)
      : *impl*\ (constructor_parameters ## __LINE__(a0, …, a ## **m**))
    {
    }

The |preprocessor|_ and |preprocessor_eval_cat|_ test programs demonstrate
proper usage of this macro.

.. _`forward`: ../../../../doc/html/boost/forward.html
.. |preprocessor| replace:: preprocessor.cpp
.. _preprocessor: ../../test/preprocessor.cpp
.. |preprocessor_eval_cat| replace:: preprocessor_eval_category.cpp
.. _preprocessor_eval_cat: ../../test/preprocessor_eval_category.cpp

``BOOST_PARAMETER_BASIC_FUNCTION(result, name, tag_namespace, arguments)``
--------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

Same as ``BOOST_PARAMETER_FUNCTION``, except:

\*. For the argument specifiers syntax, *optional-specifier* no longer
includes *default-value*.  It is up to the function body to determine the
default value of all optional arguments.

\*. Generated names in the enclosing scope no longer include
``boost_param_dispatch_0boost_ ## __LINE__ ## name`` or
``boost_param_dispatch_1boost_ ## __LINE__ ## name``.

\*. Expansion of this macro omits all overloads of
``boost_param_dispatch_0boost_ ## __LINE__ ## name`` and
``boost_param_dispatch_1boost_ ## __LINE__ ## name`` and stops at the header
of ``boost_param_impl ## name``.  Therefore, only the |ArgumentPack|_ type
``Args`` and its object instance ``args`` are available for use within the
function body.

The |preprocessor|_ test program demonstrates proper usage of this macro.

.. |preprocessor| replace:: preprocessor.cpp
.. _preprocessor: ../../test/preprocessor.cpp

``BOOST_PARAMETER_BASIC_MEMBER_FUNCTION(result, name, tag_ns, arguments)``
--------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

Same as ``BOOST_PARAMETER_BASIC_FUNCTION``, except that:

\*. ``name`` may be qualified by the ``static`` keyword to declare the member
function and its helpers as not associated with any object of the enclosing
type.

\*. Expansion of this macro omits the forward declaration of the
implementation function.

The |preprocessor|_ test program demonstrates proper usage of this macro.

.. |preprocessor| replace:: preprocessor.cpp
.. _preprocessor: ../../test/preprocessor.cpp

``BOOST_PARAMETER_BASIC_CONST_MEMBER_FUNCTION(result, name, tag_ns, args)``
---------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

Same as ``BOOST_PARAMETER_BASIC_MEMBER_FUNCTION``, except that the overloaded
forwarding member functions and their helper methods are ``const``-qualified.

The |preprocessor|_ test program demonstrates proper usage of this macro.

.. |preprocessor| replace:: preprocessor.cpp
.. _preprocessor: ../../test/preprocessor.cpp

``BOOST_PARAMETER_NAME(name)``
------------------------------

:Defined in: `boost/parameter/name.hpp`__

__ ../../../../boost/parameter/name.hpp

Declares a tag-type and keyword object.

**If** *name* is of the form:

.. parsed-literal::

    (*object-name*, *namespace-name*) *qualifier*\ (*tag-name*)

**then**

:Requires: *qualifier* is either ``in``, ``out``, ``in_out``, ``consume``,
``move_from``, or ``forward``.

Expands to:

.. parsed-literal::

    namespace *namespace-name* {

        struct *tag-name*
        {
            static char const* keyword_name()
            {
                return ## *tag-name*;
            }

            typedef *unspecified* _;
            typedef *unspecified* _1;
            typedef boost::parameter::*qualifier* ## _reference qualifier;
        };
    }

    ::boost::parameter::keyword<*tag-namespace* :: *tag-name* > const&
        *object-name* = ::boost::parameter::keyword<
            *tag-namespace* :: *tag-name*
        >::instance;

**Else If** *name* is of the form:

.. parsed-literal::

    (*tag-name*, *namespace-name*) *object-name*

**then**

Treats *name* as if it were of the form:

.. parsed-literal::

    (forward(*tag-name*), *namespace-name*) *object-name*

**Else If** *name* is of the form:

.. parsed-literal::

    *qualifier*\ (*tag-name*)

**then**

:Requires: *qualifier* is either ``in``, ``out``, ``in_out``, ``consume``,
``move_from``, or ``forward``.

Expands to:

.. parsed-literal::

    namespace tag {

        struct *tag-name*
        {
            static char const* keyword_name()
            {
                return ## *tag-name*;
            }

            typedef *unspecified* _;
            typedef *unspecified* _1;
            typedef boost::parameter::*qualifier* ## _reference qualifier;
        };
    }

    ::boost::parameter::keyword<tag:: *tag-name* > const& _ ## *tag-name*
        = ::boost::parameter::keyword<tag:: *tag-name* >::instance;

**Else**

Treats *name* as if it were of the form:

.. parsed-literal::

    forward(*tag-name*)

``BOOST_PARAMETER_TEMPLATE_KEYWORD(name)``
------------------------------------------

:Defined in: `boost/parameter/name.hpp`__

__ ../../../../boost/parameter/name.hpp

Expands to:

.. parsed-literal::

    namespace tag {

        struct *name*;
    }

    template <typename T>
    struct *name* 
      : ::boost::parameter::template_keyword<tag:: *name*, T>
    {
    };

The |function_type_tpl_param_cpp|_ test program demonstrates proper usage of
this macro.  It also shows that the generated class template stores function
types as either ``boost::function`` or ``std::function`` specializations.

.. |function_type_tpl_param_cpp| replace:: function_type_tpl_param.cpp
.. _function_type_tpl_param_cpp: ../../test/function_type_tpl_param.cpp

``BOOST_PARAMETER_FUN(r, n, l, h, p)``
--------------------------------------

.. admonition:: Deprecated

    This macro has been deprecated in favor of
    ``BOOST_PARAMETER_FUNCTION``.

Generates a sequence of `forwarding function`_ templates named
``n``, with arities ranging from ``l`` to ``h``, returning ``r``,
and using ``p`` to control overload resolution and assign tags to
positional arguments.

:Defined in: `boost/parameter/macros.hpp`__

__ ../../../../boost/parameter/macros.hpp

:Requires: ``l`` and ``h`` are nonnegative integer tokens
such that ``l`` < ``h``

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is ``#defined``, **then**

Expands to:

.. parsed-literal::

    template <typename A1, typename A2, …, typename A ## **l**>
    r
        name(
            A1 && a1, A2 && a2, …, A ## **l** && a ## **l**
          , typename **p**::match<A1, A2, …, A ## **l**>::type p = **p**\ ()
        )
    {
        return **name**\ _with_named_params(
            **p**\ (
                boost::`forward`_<A1>(a1)
              , boost::`forward`_<A2>(a2)
              , …
              , boost::`forward`_<A ## **l**>(a ## **l**)
            )
        );
    }

    template <
        typename A1
      , typename A2
      , …
      , typename A ## **l**
      , typename A ## BOOST_PP_INC_\ (**l**)
    >
    r
        name(
            A1 && a1, A2 && a2, …, A ## **l** && a ## **l**
          , A ## BOOST_PP_INC_\ (**l**) const& a ## BOOST_PP_INC_\ (**l**)
          , typename **p**::match<
                A1, A2, …, A ## **l**, A ## BOOST_PP_INC_\ (**l**)
            >::type p = **p**\ ()
        )
    {
        return **name**\ _with_named_params(
            **p**\ (
                boost::`forward`_<A1>(a1)
              , boost::`forward`_<A2>(a2)
              , …
              , boost::`forward`_<A ## **l**>(a ## **l**)
              , boost::`forward`_<A ## `BOOST_PP_INC`_\ (**l**)>(
                    a ## `BOOST_PP_INC`_\ (**l**)
                )
            )
        );
    }

    :vellipsis:`⋮`

    template <typename A1, typename A2, …, typename A ## **h**>
    r
        name(
            A1 && a1, A2 && a2, …, A ## **h** && x ## **h**
          , typename **p**::match<A1, A2, …, A ## **h**>::type p = **p**\ ()
        )
    {
        return **name**\ _with_named_params(
            **p**\ (
                boost::`forward`_<A1>(a1)
              , boost::`forward`_<A2>(a2)
              , …
              , boost::`forward`_<A ## **h**>(a ## **h**)
            )
        );
    }

**If** |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| is **not** ``#defined``,
**then**

Expands to:

.. parsed-literal::

    template <typename A1, typename A2, …, typename A ## **l**>
    r
        name(
            A1 const& a1, A2 const& a2, …, A ## **l** const& a ## **l**
          , typename **p**::match<A1, A2, …, A ## **l**>::type pk = **p**\ ()
        )
    {
        return **name**\ _with_named_params(pk(a1, a2, …, a ## **l**));
    }

    *… exponential number of overloads …*
    :vellipsis:`⋮`

    template <typename A1, typename A2, …, typename A ## **l**>
    r
        name(
            A1& a1, A2& a2, …, A ## **l** & a ## **l**
          , typename **p**::match<A1, A2, …, A ## **l**>::type pk = **p**\ ()
        )
    {
        return **name**\ _with_named_params(pk(a1, a2, …, a ## **l**));
    }

    template <
        typename A1
      , typename A2
      , …
      , typename A ## **l**
      , typename A ## `BOOST_PP_INC`_\ (**l**)
    >
    r
        name(
            A1 const& a1, A2 const& a2, …, A ## **l** const& a ## **l**
          , A ## `BOOST_PP_INC`_\ (**l**) const& a ## `BOOST_PP_INC`_\ (**l**)
          , typename **p**::match<
                A1 const, A2 const, …, A ## **l** const
              , A ## `BOOST_PP_INC`_\ (**l**) const
            >::type pk = **p**\ ()
        )
    {
        return **name**\ _with_named_params(
            pk(a1, a2, …, a ## **l**, a ## `BOOST_PP_INC`_\ (**l**))
        );
    }

    *… exponential number of overloads …*
    :vellipsis:`⋮`

    template <
        typename A1
      , typename A2
      , …
      , typename A ## **l**
      , typename A ## `BOOST_PP_INC`_\ (**l**)
    >
    r
        name(
            A1& a1, A2& a2, …, A ## **l** & a ## **l**
          , A ## `BOOST_PP_INC`_\ (**l**) & a ## `BOOST_PP_INC`_\ (**l**)
          , typename **p**::match<
                A1, A2, …, A ## **l**, A ## `BOOST_PP_INC`_\ (**l**)
            >::type pk = **p**\ ()
        )
    {
        return **name**\ _with_named_params(
            pk(a1, a2, …, a ## **l**, a ## `BOOST_PP_INC`_\ (**l**))
        );
    }

    :vellipsis:`⋮`

    template <typename A1, typename A2, …, typename A ## **h**>
    r
        name(
            A1 const& a1, A2 const& a2, …, A ## **h** const& x ## **h**
          , typename **p**::match<
                A1 const, A2 const, …, A ## **h** const
            >::type pk = **p**\ ()
        )
    {
        return **name**\ _with_named_params(pk(a1, a2, …, a ## **h**));
    }

    *… exponential number of overloads …*
    :vellipsis:`⋮`

    template <typename A1, typename A2, …, typename A ## **h**>
    r
        name(
            A1& a1, A2& a2, …, A ## **h** & x ## **h**
          , typename **p**::match<A1, A2, …, A ## **h**>::type pk = **p**\ ()
        )
    {
        return **name**\ _with_named_params(pk(a1, a2, …, a ## **h**));
    }

The |macros_cpp|_ and |macros_eval_cat_cpp|_ test programs demonstrate proper
usage of this macro.

.. _`BOOST_PP_INC`: ../../../preprocessor/doc/ref/inc.html
.. _`forward`: ../../../../doc/html/boost/forward.html
.. |macros_cpp| replace:: macros.cpp
.. _macros_cpp: ../../test/macros.cpp
.. |macros_eval_cat_cpp| replace:: macros_eval_category.cpp
.. _macros_eval_cat_cpp: ../../test/macros_eval_category.cpp

``BOOST_PARAMETER_KEYWORD(n, k)``
---------------------------------

.. admonition:: Deprecated

    This macro has been deprecated in favor of
    ``BOOST_PARAMETER_NAME``.

Generates the declaration of a |keyword tag type| named ``k`` in
namespace ``n`` and a corresponding |keyword object| definition in
the enclosing namespace.

:Defined in: `boost/parameter/keyword.hpp`__

__ ../../../../boost/parameter/keyword.hpp

Expands to:

.. parsed-literal::

    namespace **n** {

        struct **k**
        {
            typedef boost::parameter::forward_reference qualifier;
        };
    }

    namespace { 

        boost::parameter::keyword<*tag-namespace*::**k**>& **k**
            = boost::parameter::keyword<*tag-namespace*::**k**>::instance;
    }

``BOOST_PARAMETER_MATCH(p, a, x)``
----------------------------------

Generates a defaulted parameter declaration for a `forwarding function`_.

:Defined in: `boost/parameter/match.hpp`__

__ ../../../../boost/parameter/match.hpp

:Requires: ``a`` is a `Boost.Preprocessor sequence`__ of the form

.. parsed-literal::

    (A0)(A1)…(A ## *n*)

__ ../../../preprocessor/doc/data.html

Expands to:

.. parsed-literal::

    typename **p**::match<**A0**\ , **A1**\ , …, **A** ## *n*>::type
        **x** = **p**\ ()

Configuration Macros
====================

``BOOST_PARAMETER_HAS_PERFECT_FORWARDING``
------------------------------------------

Determines whether or not the library supports perfect forwarding, or the
preservation of parameter value categories.  Users can manually disable this
macro by ``#defining`` the ``BOOST_PARAMETER_DISABLE_PERFECT_FORWARDING``
macro.  Otherwise, the library will ``#define`` this macro if and only if it
and the configuration macros |BOOST_NO_FUNCTION_TEMPLATE_ORDERING|_ and
|BOOST_NO_SFINAE|_ are not already ``#defined`` but the configuration macros
|BOOST_MOVE_PERFECT_FORWARDING|_ and |BOOST_FUSION_HAS_VARIADIC_DEQUE|_ are
already defined.

.. |BOOST_PARAMETER_HAS_PERFECT_FORWARDING| replace:: ``BOOST_PARAMETER_HAS_PERFECT_FORWARDING``
.. |BOOST_NO_FUNCTION_TEMPLATE_ORDERING| replace:: ``BOOST_NO_FUNCTION_TEMPLATE_ORDERING``
.. _BOOST_NO_FUNCTION_TEMPLATE_ORDERING: ../../../config/doc/html/boost_config/boost_macro_reference.html
.. |BOOST_NO_SFINAE| replace:: ``BOOST_NO_SFINAE``
.. _BOOST_NO_SFINAE: ../../../config/doc/html/boost_config/boost_macro_reference.html
.. |BOOST_MOVE_PERFECT_FORWARDING| replace:: ``BOOST_MOVE_PERFECT_FORWARDING``
.. _BOOST_MOVE_PERFECT_FORWARDING: ../../../../boost/move/detail/workaround.hpp
.. |BOOST_FUSION_HAS_VARIADIC_DEQUE| replace:: ``BOOST_FUSION_HAS_VARIADIC_DEQUE``
.. _BOOST_FUSION_HAS_VARIADIC_DEQUE: ../../../../boost/fusion/container/deque/deque_fwd.hpp

:Defined in: `boost/parameter/config.hpp`__

__ ../../../../boost/parameter/config.hpp

``BOOST_PARAMETER_MAX_ARITY``
-----------------------------

Determines the maximum number of arguments supported by the library.  Will
only be ``#defined`` by the library if it is not already ``#defined``.

If this library supports perfect forwarding, then this macro can be safely
ignored.  Otherwise, mutable references must be wrapped by |boost_ref|_ or
|std_ref|_ if passed by position to Boost.Parameter-enabled functions with
arity higher than ``7``.

.. |BOOST_PARAMETER_MAX_ARITY| replace:: ``BOOST_PARAMETER_MAX_ARITY``
.. |boost_ref| replace:: ``boost\:\:ref``
.. _boost_ref: ../../../core/doc/html/core/ref.html
.. |std_ref| replace:: ``std\:\:ref``
.. _std_ref: http://en.cppreference.com/w/cpp/utility/functional/ref

:Defined in: `boost/parameter/config.hpp`__

__ ../../../../boost/parameter/config.hpp

:Default Value: ``8``
:Minimum Value: ``2``

``BOOST_PARAMETER_ALL_CONST_THRESHOLD_ARITY``
---------------------------------------------

If this library does **not** support perfect forwarding, determines the
minimum number of arguments that are all passed by ``const`` lvalue reference
to a function overload generated by ``BOOST_PARAMETER_FUNCTION`` et. al.  Will
only be ``#defined`` by the library if it is not already ``#defined`` and
``BOOST_PARAMETER_HAS_PERFECT_FORWARDING`` is **not** ``#defined``.

.. |BOOST_PARAMETER_ALL_CONST_THRESHOLD_ARITY| replace:: ``BOOST_PARAMETER_ALL_CONST_THRESHOLD_ARITY``

:Defined in: `boost/parameter/config.hpp`__

__ ../../../../boost/parameter/config.hpp

:Default Value: ``11``
:Minimum Value: ``1``

``BOOST_PARAMETER_USES_BOOST_VICE_CXX11_TYPE_TRAITS``
-----------------------------------------------------

Determines whether or not the library uses |Boost.TypeTraits|_ internally
instead of the corresponding C++ standard utilities.  Users can manually
``#define`` this macro if they suspect that their compilers are reporting
internal errors otherwise.

.. |Boost.TypeTraits| replace:: **Boost.TypeTraits**
.. _Boost.TypeTraits: ../../../type_traits/doc/html/index.html

:Defined in: `boost/parameter/config.hpp`__

__ ../../../../boost/parameter/config.hpp

Tutorial
========

Follow `this link`__ to the Boost.Parameter tutorial documentation.  

__ index.html#tutorial

//////////////////////////////////////////////////////////////////////////////

.. [#thread] References to tag objects may be initialized multiple
    times.  This scenario can only occur in the presence of
    threading.  Because the C++ standard doesn't consider threading,
    it doesn't explicitly allow or forbid multiple initialization of
    references.  That said, it's hard to imagine an implementation
    where it could make a difference. 

.. [#no_result_of] Where |BOOST_NO_RESULT_OF|_ is ``#defined``,
    ``boost::``\ |result_of|_\ ``<F()>::type`` is replaced by
    ``F::result_type``.

.. |result_of| replace:: ``result_of``
.. _result_of: ../../../utility/utility.htm#result_of

.. |BOOST_NO_RESULT_OF| replace:: ``BOOST_NO_RESULT_OF``
.. _BOOST_NO_RESULT_OF: ../../../utility/utility.htm#BOOST_NO_RESULT_OF

